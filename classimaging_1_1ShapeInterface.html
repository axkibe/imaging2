<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>imaging2: imaging::ShapeInterface Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceimaging.html">imaging</a>::<a class="el" href="classimaging_1_1ShapeInterface.html">ShapeInterface</a>
  </div>
</div>
<div class="contents">
<h1>imaging::ShapeInterface Class Reference<br>
<small>
[<a class="el" href="group__shape.html">Shape Module</a>]</small>
</h1><!-- doxytag: class="imaging::ShapeInterface" -->Abstract class interface for shapes on a shape parameter manifold.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="ShapeInterface_8hpp-source.html">ShapeInterface.hpp</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for imaging::ShapeInterface:</div>
<div class="dynsection">

<p><center><img src="classimaging_1_1ShapeInterface.png" usemap="#imaging::ShapeInterface_map" border="0" alt=""></center>
<map name="imaging::ShapeInterface_map">
<area href="classimaging_1_1BsplineShape.html" alt="imaging::BsplineShape" shape="rect" coords="0,56,605,80">
<area href="classimaging_1_1Circle.html" alt="imaging::Circle" shape="rect" coords="615,56,1220,80">
<area href="classimaging_1_1MrepModel.html" alt="imaging::MrepModel< position_t, atom_t, connection_t >" shape="rect" coords="1230,56,1835,80">
<area href="classimaging_1_1MrepModel.html" alt="imaging::MrepModel< imaging::Position2d, imaging::MrepAtom, imaging::imaging::MrepConnection< 2 > >" shape="rect" coords="1845,56,2450,80">
<area href="classimaging_1_1MrepSkeleton2d.html" alt="imaging::MrepSkeleton2d" shape="rect" coords="1230,112,1835,136">
<area href="classimaging_1_1MrepModel2d.html" alt="imaging::MrepModel2d" shape="rect" coords="922,168,1527,192">
<area href="classimaging_1_1PolygonModel2d.html" alt="imaging::PolygonModel2d" shape="rect" coords="1537,168,2142,192">
</map>
</div>

<p>
<a href="classimaging_1_1ShapeInterface-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1ShapeInterface.html#254b2997195ae41a715ef7d7dd0284af">exponential</a> (const ublas::vector&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &gt; &amp;vector, <a class="el" href="classimaging_1_1ShapeInterface.html">ShapeInterface</a> &amp;shape) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1ShapeInterface.html#f334a39e62f24abbf78c18a8e24b2620">logarithm</a> (const <a class="el" href="classimaging_1_1ShapeInterface.html">ShapeInterface</a> &amp;shape, ublas::vector&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &gt; &amp;vector) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1ShapeInterface.html#849b0706249664f28cf28dea12312363">dimension</a> () const =0</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Abstract class interface for shapes on a shape parameter manifold. 
<p>
This class interface defines shapes, which are determined by parameters on a Riemannian manifold. I.e. every shape implements the Riemannian exponential which maps vectors to a shape in its neighborhood. The Riemannian logarithm maps shapes in this neighborhood back to its Riemannian coordinates with respect to the reference shape. If we denote the Riemannian manifold as <img class="formulaInl" alt="$M$" src="form_90.png"> then every shape <img class="formulaInl" alt="$p$" src="form_91.png"> has to implement <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \textrm{Exp}_p: T_pM \rightarrow M \]" src="form_92.png">
<p>
 and <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \textrm{Log}_p: M \rightarrow T_pM \]" src="form_93.png">
<p>
<p>
The following example shows how this enables computations with shapes without the knowledge of details about the shape implementation. It computes the Riemannian logarithm with respect to the first shape of each of the remaining shapes. Then the mean of the logarithms is computed and mapped back to a shape. The function is fully generic, i.e. it does not know what the actual shapes it processes are.<p>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> shape_t&gt;
  <span class="keywordtype">void</span> compute_mean(<span class="keyword">const</span> std::vector&lt;shape_t&gt; &amp; shapes, shape_t &amp; mean_shape)
  {
    <span class="keywordflow">if</span>(shapes.size() == 0)
      <span class="keywordflow">return</span>;
      
    std::vector&lt; ublas::vector&lt;float_t&gt; &gt; logarithms(shapes.size() - 1);
    ublas::vector&lt;float_t&gt; logarithm_of_mean;
      
    shape_t &amp; reference_shape = shapes[0]; <span class="comment">// create an alias for the first shape</span>
                                           <span class="comment">// we call it reference_shape</span>
                                           
    logarithm_of_mean = ublas::scalar_vector(reference_shape.dimension(), 0.0);
    <span class="comment">// set the vector which will be the logarithm of the mean shape to zero</span>
    
    ublas::vector&lt;float_t&gt; <a class="code" href="classimaging_1_1ShapeInterface.html#f334a39e62f24abbf78c18a8e24b2620">logarithm</a>(reference_shape.dimension());
    <span class="comment">// will hold the logarithm of each shape in the loop below</span>
    
    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 1; i &lt; shapes.size(); ++i)
    {
      reference_shape.logarithm(shapes[i], <a class="code" href="classimaging_1_1ShapeInterface.html#f334a39e62f24abbf78c18a8e24b2620">logarithm</a>); <span class="comment">// computes the logarithm</span>
      logarithm_of_mean += <a class="code" href="classimaging_1_1ShapeInterface.html#f334a39e62f24abbf78c18a8e24b2620">logarithm</a>; <span class="comment">// adds it to the scaled mean</span>
    }
    
    logarithm_of_mean /= <a class="code" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>(shapes.size()); <span class="comment">// scales the mean correctly</span>
    
    reference_shape.exponential(logarithm_of_mean, mean_shape);
    <span class="comment">// computes the shape determined by logarithm_of_mean</span>
  }
</pre></div> <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="254b2997195ae41a715ef7d7dd0284af"></a><!-- doxytag: member="imaging::ShapeInterface::exponential" ref="254b2997195ae41a715ef7d7dd0284af" args="(const ublas::vector&lt; float_t &gt; &amp;vector, ShapeInterface &amp;shape) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void imaging::ShapeInterface::exponential           </td>
          <td>(</td>
          <td class="paramtype">const ublas::vector&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classimaging_1_1ShapeInterface.html">ShapeInterface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>shape</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the Riemannian exponential of <em>vector</em> with respect to <em>*this</em> and stores the result in <em>shape</em>. In other words, <em>shape</em> is the projection of the tangent vector <em>vector</em> in the tangent space at the <em>*this</em> shape on the shape manifold. 
<p>Implemented in <a class="el" href="classimaging_1_1BsplineShape.html#41c0a9de52f27050623e8219e5ee20ca">imaging::BsplineShape</a>, <a class="el" href="classimaging_1_1Circle.html#c90c1f4a374c61acd2958e2b98153101">imaging::Circle</a>, <a class="el" href="classimaging_1_1MrepModel.html#6989dc70d6fc47eb1c4b06290b0e9a0f">imaging::MrepModel&lt; position_t, atom_t, connection_t &gt;</a>, and <a class="el" href="classimaging_1_1MrepModel.html#6989dc70d6fc47eb1c4b06290b0e9a0f">imaging::MrepModel&lt; imaging::Position2d, imaging::MrepAtom, imaging::imaging::MrepConnection&lt; 2 &gt; &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="f334a39e62f24abbf78c18a8e24b2620"></a><!-- doxytag: member="imaging::ShapeInterface::logarithm" ref="f334a39e62f24abbf78c18a8e24b2620" args="(const ShapeInterface &amp;shape, ublas::vector&lt; float_t &gt; &amp;vector) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void imaging::ShapeInterface::logarithm           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classimaging_1_1ShapeInterface.html">ShapeInterface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ublas::vector&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vector</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the Riemannian logarithm of <em>shape</em> with respect to <em>*this</em> and stores the result in <em>vector</em>. In other words, <em>vector</em> is the projection of <em>shape</em> on the tangent space at the <em>*this</em> shape on the shape manifold. 
<p>Implemented in <a class="el" href="classimaging_1_1BsplineShape.html#515776b6837ecd2e1258a58f0c372d01">imaging::BsplineShape</a>, <a class="el" href="classimaging_1_1Circle.html#522acb1d5d9ee02e11b0b4a1f8e29729">imaging::Circle</a>, <a class="el" href="classimaging_1_1MrepModel.html#939317d75fa9a969b55ad5a852e96b04">imaging::MrepModel&lt; position_t, atom_t, connection_t &gt;</a>, and <a class="el" href="classimaging_1_1MrepModel.html#939317d75fa9a969b55ad5a852e96b04">imaging::MrepModel&lt; imaging::Position2d, imaging::MrepAtom, imaging::imaging::MrepConnection&lt; 2 &gt; &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="849b0706249664f28cf28dea12312363"></a><!-- doxytag: member="imaging::ShapeInterface::dimension" ref="849b0706249664f28cf28dea12312363" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> imaging::ShapeInterface::dimension           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the parametric dimension of the shape object. This is the same as the dimension of the shape manifold the shape belongs to. It should not be confused with the spatial dimension <em>N</em>. 
<p>Implemented in <a class="el" href="classimaging_1_1BsplineShape.html#cfdb6302e4198d38e507425b0ee54f12">imaging::BsplineShape</a>, <a class="el" href="classimaging_1_1Circle.html#a036fbc7e88b679a6de8428d12901603">imaging::Circle</a>, <a class="el" href="classimaging_1_1MrepModel.html#7c880f5ced9f6eb826a635e93e7a3046">imaging::MrepModel&lt; position_t, atom_t, connection_t &gt;</a>, and <a class="el" href="classimaging_1_1MrepModel.html#7c880f5ced9f6eb826a635e93e7a3046">imaging::MrepModel&lt; imaging::Position2d, imaging::MrepAtom, imaging::imaging::MrepConnection&lt; 2 &gt; &gt;</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>imaging2/shape/<a class="el" href="ShapeInterface_8hpp-source.html">ShapeInterface.hpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Feb 10 10:01:31 2009 for imaging2 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
