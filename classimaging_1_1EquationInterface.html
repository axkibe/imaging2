<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>imaging2: imaging::EquationInterface&lt; fem_types &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceimaging.html">imaging</a>::<a class="el" href="classimaging_1_1EquationInterface.html">EquationInterface</a>
  </div>
</div>
<div class="contents">
<h1>imaging::EquationInterface&lt; fem_types &gt; Class Template Reference<br>
<small>
[<a class="el" href="group__fem__equation.html">Equations</a>]</small>
</h1><!-- doxytag: class="imaging::EquationInterface" -->Abstract base class of all PDEs to be solved using the finite element module.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="EquationInterface_8hpp-source.html">EquationInterface.hpp</a>&gt;</code>
<p>

<p>
<a href="classimaging_1_1EquationInterface-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1EquationInterface.html#0ed1bab5be77fb54a1aed6d790ca34f3">system_size</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1EquationInterface.html#2f0bac6d6267e8310673ba77bec416f1">stiffness_matrix</a> (std::size_t k, std::size_t l, std::size_t i, std::size_t j, std::size_t integrator_node, const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; fem_types &gt; &amp;kernel) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1EquationInterface.html#087333e257119d73bae28d9c1a52325e">force_vector</a> (std::size_t k, std::size_t i, std::size_t integrator_node, const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; fem_types &gt; &amp;kernel) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1EquationInterface.html#2e42aa150ca04aeaf3c7eff402eefbea">stiffness_matrix_at_boundary</a> (std::size_t k, std::size_t l, std::size_t i, std::size_t j, std::size_t integrator_node, const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; fem_types &gt; &amp;kernel) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1EquationInterface.html#5a784e34da8b9d2057b4e366e6d31b8e">force_vector_at_boundary</a> (std::size_t k, std::size_t i, std::size_t integrator_node, const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; fem_types &gt; &amp;kernel) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1EquationInterface.html#2393215f2c285d430ac33d787200b177">sanity_check_stiffnesss_matrix</a> (const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; fem_types &gt; &amp;kernel, std::string &amp;error_message) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1EquationInterface.html#70fff5cffd8c40a6b1f817b67b8754cb">sanity_check_force_vector</a> (const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; fem_types &gt; &amp;kernel, std::string &amp;error_message) const </td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class fem_types&gt;<br>
 class imaging::EquationInterface&lt; fem_types &gt;</h3>

Abstract base class of all PDEs to be solved using the finite element module. 
<p>
To solve a (system of) PDEs with the <em>imaging2</em> finite element module the user must design a class which implements the public members of this interface. It is also recommended to actually derive your class from <a class="el" href="classimaging_1_1EquationInterface.html" title="Abstract base class of all PDEs to be solved using the finite element module.">EquationInterface</a>. Then, an object of this class should be passed to <a class="el" href="classimaging_1_1Assembler.html#fd1570fa5cbd33b81e8435c01ac9f244">Assembler::assemble()</a>, <a class="el" href="classimaging_1_1Assembler.html#05276ecac49451b7f5a6d27db14d462e">Assembler::assemble_stiffness_matrix()</a> or <a class="el" href="classimaging_1_1Assembler.html#d7ae282c310e3805990efdd6a5f332b9">Assembler::assemble_force_vector()</a> to compute the system of linear equation corresponding to the PDE.<p>
The interface consists of four functions computing the coefficients in the stiffness matrix and the force vector respectively for a given element (determined by the current state of <a class="el" href="classimaging_1_1FemKernel.html" title="Computes the values of the shape functions and the element transformation in the...">FemKernel</a>). The function <a class="el" href="classimaging_1_1EquationInterface.html#0ed1bab5be77fb54a1aed6d790ca34f3">system_size()</a> returns the number of equations in the system of PDEs.<p>
For scalar PDEs it is advisable to make use of the interface <a class="el" href="classimaging_1_1SimpleEquationInterface.html" title="Abstract base class of scalar, elliptic PDEs in divergence form.">SimpleEquationInterface</a>. A simple equation can be transformed into a equation complying with <a class="el" href="classimaging_1_1EquationInterface.html" title="Abstract base class of all PDEs to be solved using the finite element module.">EquationInterface</a> by using <a class="el" href="classimaging_1_1SimpleEquationAdaptor.html" title="Converts a SimpleEquationInterface object into an EquationInterface object.">SimpleEquationAdaptor</a>.<p>
To understand the parameters of the member function we give a (very technical) definition of the PDE problem this interface can model. Imagine that we are interested in the problem <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \vec F(\vec u) = \vec f\,, \]" src="form_8.png">
<p>
 where <img class="formulaInl" alt="$\vec F$" src="form_9.png"> depends on the vector-valued function <img class="formulaInl" alt="$\vec u$" src="form_10.png"> and its (higher order) derivative. We will rewrite this equation as <p class="formulaDsp">
<img class="formulaDsp" alt="\[ F^k\big((u^\ell)_\ell\big) = f^k\,, \]" src="form_11.png">
<p>
 where <img class="formulaInl" alt="$k$" src="form_12.png"> and <img class="formulaInl" alt="$\ell$" src="form_13.png"> are indices in the range of the number of equations of the system. Furthermore we assume a basis <img class="formulaInl" alt="$(\psi_i)_i$" src="form_14.png"> of shape functions on the problem domain, where each <img class="formulaInl" alt="$\psi_i$" src="form_15.png"> corresponds to a node on the grid. We define the vector-valued shape functions <img class="formulaInl" alt="$\vec \psi_i^k$" src="form_16.png"> as <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \big(\vec \psi_i^k\big)^m = \delta_{km} \psi_i\,. \]" src="form_17.png">
<p>
<p>
Following the common finite element approach we we express the unknown function <img class="formulaInl" alt="$\vec u$" src="form_10.png"> in terms of the shape functions, i.e. <p class="formulaDsp">
<img class="formulaDsp" alt="\[ u^\ell = \sum_i u_i^\ell \psi_i\,. \]" src="form_18.png">
<p>
 We hit the above equation with each of the test functions and integrate the resulting equations: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_\Omega \vec F(\vec u) \cdot \vec \psi_j^k = \int_\Omega \vec f \cdot \vec \psi_j^k\,. \]" src="form_19.png">
<p>
 Then we can write the above equation in the following form: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sum_i \sum_\ell u_i^\ell \int_\Omega F^{k\ell}_i (\vec u) \psi_j = \int_\Omega f^k \psi_j\,. \]" src="form_20.png">
<p>
 Applying the Trace Theorem yields an extended version of this equation (to save symbols we re-use <img class="formulaInl" alt="$F$" src="form_21.png"> and <img class="formulaInl" alt="$f$" src="form_22.png">; they are <em>not</em> the same functions as above): <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sum_i \sum_\ell u_i^\ell \Big(\underbrace{\int_\Omega F^{k\ell}_i(\vec u, \psi_j)}_{A^{k\ell}_{ij}} + \underbrace{\int_{\partial \Omega} G^{k\ell}_i(\vec u, \psi_j)}_{B^{k\ell}_{ij}} \Big) = \underbrace{\int_\Omega f^k(\psi_j)}_{a^k_j} + \underbrace{\int_{\partial \Omega} g^k(\psi_j)}_{b^k_j} \,. \]" src="form_23.png">
<p>
 The parts <img class="formulaInl" alt="$A^{k\ell}_{ij}$" src="form_24.png">, <img class="formulaInl" alt="$B^{k\ell}_{ij}$" src="form_25.png">, <img class="formulaInl" alt="$a^k_j$" src="form_26.png"> and <img class="formulaInl" alt="$b^k_j$" src="form_27.png"> then correspond to the four members we mentioned in the introduction. Note that the above version of the equation is not uniquely determined. It depends on how the user applies the Trace Theorem, i.e. which parts of the equation you chose to transport to the boundary.<p>
If she also must incorporate boundary conditions she might choose not to evaluate the equation on the boundary at all. This is equivalent to hit the equation with test functions with compact support only. Then, the terms <img class="formulaInl" alt="$B^{k\ell}_{ij}$" src="form_25.png"> and <img class="formulaInl" alt="$b^k_j$" src="form_27.png"> vanish at first. Instead, consider boundary conditions <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \vec G(\vec u) = \vec g\quad \textrm{on }\partial \Omega\,. \]" src="form_28.png">
<p>
 and hit them with non-compactly supported test functions of the above form, i.e. test functions <img class="formulaInl" alt="$\vec \psi_i^k$" src="form_16.png"> where <img class="formulaInl" alt="$i$" src="form_29.png"> refers to a boundary node. Performing the same procedure as above on this equation adds the terms <img class="formulaInl" alt="$B^{k\ell}_{ij}$" src="form_25.png"> and <img class="formulaInl" alt="$b^k_j$" src="form_27.png"> again (this time as a result of the boundary equation and not of the Trace Theorem). <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="0ed1bab5be77fb54a1aed6d790ca34f3"></a><!-- doxytag: member="imaging::EquationInterface::system_size" ref="0ed1bab5be77fb54a1aed6d790ca34f3" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classimaging_1_1EquationInterface.html">imaging::EquationInterface</a>&lt; fem_types &gt;::system_size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of equations in this system of PDEs. For scalar PDEs this is 1. 
<p>Reimplemented in <a class="el" href="classimaging_1_1SimpleEquationAdaptor.html#6e6180306f768a4ad81f4e0f90d8888a">imaging::SimpleEquationAdaptor&lt; equation_t &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="2f0bac6d6267e8310673ba77bec416f1"></a><!-- doxytag: member="imaging::EquationInterface::stiffness_matrix" ref="2f0bac6d6267e8310673ba77bec416f1" args="(std::size_t k, std::size_t l, std::size_t i, std::size_t j, std::size_t integrator_node, const FemKernel&lt; fem_types &gt; &amp;kernel) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> <a class="el" href="classimaging_1_1EquationInterface.html">imaging::EquationInterface</a>&lt; fem_types &gt;::stiffness_matrix           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>integrator_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; fem_types &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>kernel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the contribution of the integral <img class="formulaInl" alt="$A^{k\ell}_{ij}$" src="form_24.png"> in <em>integrator_node</em> on the current element of <em>kernel</em>. The node indices <em>i</em> and <em>j</em> are node indices on the element, not global indices.<p>
As <em>kernel</em> is set to the current element, in the implementation of this function all relevant values of the shape functions and the element transform can be retrieved from <em>kernel</em> via the indices <em>i</em>, <em>j</em> and <em>integrator_node</em>. One can also obtain the FE grid from the kernel (<a class="el" href="classimaging_1_1FemKernel.html#3a0ac5880414db3603a76a358e8d32bd">FemKernel::grid()</a>) and use its interpolation methods (passing the already correctly initialized <em>kernel</em> to them). 
<p>Reimplemented in <a class="el" href="classimaging_1_1SimpleEquationAdaptor.html#9f5912ecaf80f97250c6d396dd6c1412">imaging::SimpleEquationAdaptor&lt; equation_t &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="087333e257119d73bae28d9c1a52325e"></a><!-- doxytag: member="imaging::EquationInterface::force_vector" ref="087333e257119d73bae28d9c1a52325e" args="(std::size_t k, std::size_t i, std::size_t integrator_node, const FemKernel&lt; fem_types &gt; &amp;kernel) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> <a class="el" href="classimaging_1_1EquationInterface.html">imaging::EquationInterface</a>&lt; fem_types &gt;::force_vector           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>integrator_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; fem_types &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>kernel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the contribution of the integral <img class="formulaInl" alt="$a^k_j$" src="form_26.png"> in <em>integrator_node</em> on the current element of <em>kernel</em>. The node index <em>i</em> is the node index on the element, not a global index.<p>
As <em>kernel</em> is set to the current element, in the implementation of this function all relevant values of the shape functions and the element transform can be retrieved from <em>kernel</em> via the indices <em>i</em> and <em>integrator_node</em>. One can also obtain the FE grid from the kernel (<a class="el" href="classimaging_1_1FemKernel.html#3a0ac5880414db3603a76a358e8d32bd">FemKernel::grid()</a>) and use its interpolation methods (passing the already correctly initialized <em>kernel</em> to them). 
<p>Reimplemented in <a class="el" href="classimaging_1_1SimpleEquationAdaptor.html#439d4ea4e32017f6f6184f95fb49b557">imaging::SimpleEquationAdaptor&lt; equation_t &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="2e42aa150ca04aeaf3c7eff402eefbea"></a><!-- doxytag: member="imaging::EquationInterface::stiffness_matrix_at_boundary" ref="2e42aa150ca04aeaf3c7eff402eefbea" args="(std::size_t k, std::size_t l, std::size_t i, std::size_t j, std::size_t integrator_node, const FemKernel&lt; fem_types &gt; &amp;kernel) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> <a class="el" href="classimaging_1_1EquationInterface.html">imaging::EquationInterface</a>&lt; fem_types &gt;::stiffness_matrix_at_boundary           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>integrator_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; fem_types &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>kernel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the contribution of the integral <img class="formulaInl" alt="$B^{k\ell}_{ij}$" src="form_25.png"> in <em>integrator_node</em> on the current boundary element of <em>kernel</em>. The node indices <em>i</em> and <em>j</em> are node indices on the element, not global indices.<p>
As <em>kernel</em> is set to the current boundary element, in the implementation of this function all relevant values of the shape functions and the element transform can be retrieved from <em>kernel</em> via the indices <em>i</em>, <em>j</em> and <em>integrator_node</em>. One can also obtain the FE grid from the kernel (<a class="el" href="classimaging_1_1FemKernel.html#3a0ac5880414db3603a76a358e8d32bd">FemKernel::grid()</a>) and use its interpolation methods (passing the already correctly initialized <em>kernel</em> to them). 
<p>Reimplemented in <a class="el" href="classimaging_1_1SimpleEquationAdaptor.html#37ce2e80b2dc622f3dac71664aba8607">imaging::SimpleEquationAdaptor&lt; equation_t &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="5a784e34da8b9d2057b4e366e6d31b8e"></a><!-- doxytag: member="imaging::EquationInterface::force_vector_at_boundary" ref="5a784e34da8b9d2057b4e366e6d31b8e" args="(std::size_t k, std::size_t i, std::size_t integrator_node, const FemKernel&lt; fem_types &gt; &amp;kernel) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> <a class="el" href="classimaging_1_1EquationInterface.html">imaging::EquationInterface</a>&lt; fem_types &gt;::force_vector_at_boundary           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>integrator_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; fem_types &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>kernel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the contribution of the integral <img class="formulaInl" alt="$b^k_j$" src="form_27.png"> in <em>integrator_node</em> on the current element of <em>kernel</em>. The node index <em>i</em> is the node index on the element, not a global index.<p>
As <em>kernel</em> is set to the current boundary element, in the implementation of this function all relevant values of the shape functions and the element transform can be retrieved from <em>kernel</em> via the indices <em>i</em> and <em>integrator_node</em>. One can also obtain the FE grid from the kernel (<a class="el" href="classimaging_1_1FemKernel.html#3a0ac5880414db3603a76a358e8d32bd">FemKernel::grid()</a>) and use its interpolation methods (passing the already correctly initialized <em>kernel</em> to them). 
<p>Reimplemented in <a class="el" href="classimaging_1_1SimpleEquationAdaptor.html#c6b9a95d3123b70561005165e318c58f">imaging::SimpleEquationAdaptor&lt; equation_t &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="2393215f2c285d430ac33d787200b177"></a><!-- doxytag: member="imaging::EquationInterface::sanity_check_stiffnesss_matrix" ref="2393215f2c285d430ac33d787200b177" args="(const FemKernel&lt; fem_types &gt; &amp;kernel, std::string &amp;error_message) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classimaging_1_1EquationInterface.html">imaging::EquationInterface</a>&lt; fem_types &gt;::sanity_check_stiffnesss_matrix           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; fem_types &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>error_message</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if the dimension of the data corresponds to the dimension of the grid stored in <em>kernel</em> for the assembly of the stiffness matrix.<p>
This function is called by the assemble routine right before the assembly of the stiffness matrix. It should return <em>false</em> if data which is necessary for the assembly of the stiffness matrix is still missing. Otherwise, return <em>true</em>; 
</div>
</div><p>
<a class="anchor" name="70fff5cffd8c40a6b1f817b67b8754cb"></a><!-- doxytag: member="imaging::EquationInterface::sanity_check_force_vector" ref="70fff5cffd8c40a6b1f817b67b8754cb" args="(const FemKernel&lt; fem_types &gt; &amp;kernel, std::string &amp;error_message) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classimaging_1_1EquationInterface.html">imaging::EquationInterface</a>&lt; fem_types &gt;::sanity_check_force_vector           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; fem_types &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>error_message</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if the dimension of the data corresponds to the dimension of the grid stored in <em>kernel</em> for the assembly of the force vector.<p>
This function is called by the assemble routine right before the assembly of the force vector. It should return <em>false</em> if data which is necessary for the assembly of the force vector is still missing. Otherwise, return <em>true</em>; 
<p>Reimplemented in <a class="el" href="classimaging_1_1SimpleEquationAdaptor.html#8aeb3b57c4809e51135d178948cc6ac9">imaging::SimpleEquationAdaptor&lt; equation_t &gt;</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>imaging2/fem/equation/<a class="el" href="EquationInterface_8hpp-source.html">EquationInterface.hpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Feb 10 10:01:31 2009 for imaging2 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
