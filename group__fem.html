<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>imaging2: Finite Element Module</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Finite Element Module</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fem__equation.html">Equations</a></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Assembler.html">imaging::Assembler</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assembles the stiffness matrix and force vector of a FE problem.  <a href="classimaging_1_1Assembler.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1ElementIntegrator.html">imaging::ElementIntegrator&lt; N, N_NODES &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract base class of all integrator classes.  <a href="classimaging_1_1ElementIntegrator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1SquareIntegrator.html">imaging::SquareIntegrator&lt; N_NODES &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gaussian integrator on the square.  <a href="classimaging_1_1SquareIntegrator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1CubeIntegrator.html">imaging::CubeIntegrator&lt; N_NODES &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gaussian integrator on the square.  <a href="classimaging_1_1CubeIntegrator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1TriangleIntegrator.html">imaging::TriangleIntegrator&lt; N_NODES &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gaussian integrator on the triangle.  <a href="classimaging_1_1TriangleIntegrator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1TetrahedraIntegrator.html">imaging::TetrahedraIntegrator&lt; N_NODES &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gaussian integrator on the tetrahedron.  <a href="classimaging_1_1TetrahedraIntegrator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1IntervalIntegrator.html">imaging::IntervalIntegrator&lt; N_NODES &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gaussian integrator on the symmetric unit interval.  <a href="classimaging_1_1IntervalIntegrator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1PointIntegrator.html">imaging::PointIntegrator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">(Gaussian) integrator on a point.  <a href="classimaging_1_1PointIntegrator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1FeFunctionInterface.html">imaging::FeFunctionInterface</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract base class of FE approximations of functions.  <a href="classimaging_1_1FeFunctionInterface.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1fem__1d__types.html">imaging::fem_1d_types</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">FE types for a 1-dimensional FE problem.  <a href="classimaging_1_1fem__1d__types.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1fem__2d__square__types.html">imaging::fem_2d_square_types</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">FE types for a 2-dimensional FE problem with rectangular elements.  <a href="classimaging_1_1fem__2d__square__types.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1fem__2d__triangle__types.html">imaging::fem_2d_triangle_types</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">FE types for a 2-dimensional FE problem with triangular elements.  <a href="classimaging_1_1fem__2d__triangle__types.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1fem__3d__cube__types.html">imaging::fem_3d_cube_types</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">FE types for a 3-dimensional FE problem with cube elements.  <a href="classimaging_1_1fem__3d__cube__types.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1fem__3d__tetrahedra__types.html">imaging::fem_3d_tetrahedra_types</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">FE types for a 3-dimensional FE problem with tetrahedral elements.  <a href="classimaging_1_1fem__3d__tetrahedra__types.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1FemKernel.html">imaging::FemKernel&lt; fem_types &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the values of the shape functions and the element transformation in the integration nodes.  <a href="classimaging_1_1FemKernel.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html">imaging::Grid&lt; fem_types &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides the data structure and accessor functions for a FE grid.  <a href="classimaging_1_1Grid.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Image2Grid.html">imaging::Image2Grid&lt; fem_types &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs FE grids from multi-dimensional images and provides conversion functions between grid and image.  <a href="classimaging_1_1Image2Grid.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1ShapeFunction.html">imaging::ShapeFunction&lt; N_NODES, N_FACE_NODES, N &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract base class of all shape functions classes.  <a href="classimaging_1_1ShapeFunction.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Bilinear2dShapeFunction.html">imaging::Bilinear2dShapeFunction</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bilinear shape function on the square.  <a href="classimaging_1_1Bilinear2dShapeFunction.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Linear2dShapeFunction.html">imaging::Linear2dShapeFunction</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Linear shape function on the triangle.  <a href="classimaging_1_1Linear2dShapeFunction.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Linear3dShapeFunction.html">imaging::Linear3dShapeFunction</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Linear shape function on the tetrahedra.  <a href="classimaging_1_1Linear3dShapeFunction.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Linear1dShapeFunction.html">imaging::Linear1dShapeFunction</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Linear shape function on the symmetric unit interval.  <a href="classimaging_1_1Linear1dShapeFunction.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1SimpleAssembler.html">imaging::SimpleAssembler</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assembles the stiffness matrix and force vector of a FE problem implementing <a class="el" href="classimaging_1_1SimpleEquationInterface.html" title="Abstract base class of scalar, elliptic PDEs in divergence form.">SimpleEquationInterface</a>.  <a href="classimaging_1_1SimpleAssembler.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Transform.html">imaging::Transform&lt; N_VERTICES, N_FACES, N &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract base class of all transformations of the reference element to an element of the FE grid.  <a href="classimaging_1_1Transform.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Square2dTransform.html">imaging::Square2dTransform</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transformation of the square reference element.  <a href="classimaging_1_1Square2dTransform.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Triangle2dTransform.html">imaging::Triangle2dTransform</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transformation of the triangle reference element.  <a href="classimaging_1_1Triangle2dTransform.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Tetrahedra3dTransform.html">imaging::Tetrahedra3dTransform</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transformation of the tetrahedra reference element.  <a href="classimaging_1_1Tetrahedra3dTransform.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Cube3dTransform.html">imaging::Cube3dTransform</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transformation of the symmetric unit interval reference element.  <a href="classimaging_1_1Cube3dTransform.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Interval1dTransform.html">imaging::Interval1dTransform</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transformation of the symmetric unit cube reference element. TODO:.  <a href="classimaging_1_1Interval1dTransform.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class fem_types, class function_t&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">function_t::value_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fem.html#gc3637fa06de45896d3fba48aa67dcc79">imaging::integrate</a> (const function_t &amp;function, const Grid&lt; fem_types &gt; &amp;grid)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class fem_types, class function_t&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">function_t::value_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fem.html#g50adcd56cea88af7e5279de876b387ac">imaging::maximum</a> (const function_t &amp;function, const Grid&lt; fem_types &gt; &amp;grid)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class fem_types, class function_t&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">function_t::value_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fem.html#ga3b91cabef45ea73dea64ecfeb61dd14">imaging::minimum</a> (const function_t &amp;function, const Grid&lt; fem_types &gt; &amp;grid)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class fem_types, class function_t&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">function_t::value_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fem.html#gb4b811eb98a133a51801dce05bdcf231">imaging::average</a> (const function_t &amp;function, const Grid&lt; fem_types &gt; &amp;grid)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fem.html#gca2d9ab138fbd2ad652842b14b70b211">imaging::uniform_grid</a> (float_t lower_bound, float_t upper_bound, std::size_t n_elements, Grid&lt; fem_1d_types &gt; &amp;grid, ublas::compressed_matrix&lt; float_t &gt; &amp;stiffness_matrix_prototype, std::size_t system_size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fem.html#g198d3fac52e398a1a1b89d048f95ebe7">imaging::circle_grid</a> (float_t radius, std::size_t n_rings, Grid&lt; fem_2d_triangle_types &gt; &amp;grid, ublas::compressed_matrix&lt; float_t &gt; &amp;stiffness_matrix_prototype, std::size_t system_size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fem.html#gb469174069f35c09d24bebb7f3219a7b">imaging::ellipse_grid</a> (float_t a, float_t b, std::size_t n_rings, Grid&lt; fem_2d_triangle_types &gt; &amp;grid, ublas::compressed_matrix&lt; float_t &gt; &amp;stiffness_matrix_prototype, std::size_t system_size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fem.html#gd27044c294dff15339ef3bb45d59b63f">imaging::triangulate_shape</a> (const BoundaryDiscretizer&lt; 2 &gt; &amp;shape_discretizer, float_t max_triangle_area, Grid&lt; fem_2d_triangle_types &gt; &amp;grid, ublas::compressed_matrix&lt; float_t &gt; &amp;stiffness_matrix_prototype, std::size_t system_size)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h2><a class="anchor" name="introduction">
Introduction</a></h2>
The Finite Element Module implements data structurs and methods to assembly the stiffness matrix and the force vector for a given equation and a given finite element grid. The classes of this module can be roughly divided into <em>problem-centric</em> and <em>implementation-centric</em> classes. In addition, there some utilities classes for frequent FE-related tasks.<p>
The problem-centric classes provide data structure and functionality which are specific to a given FE problem and can only be partially provided by the imaging2 library. These cover<ul>
<li>the geometry of the FE-grid and</li><li>the equation.</li></ul>
<p>
The implementation-centric classes provide the part of FE-code which does not depend on the actual geometry and equation. An implementation of implementation-centric classes is provided by the <em>imaging2</em> library but it can be extended by the user. It consists of<ul>
<li>(boundary) elements and transformations to the reference elements,</li><li>shape functions on elements,</li><li>assembly routines.</li></ul>
<p>
The central idea of the FEM module is to be generic. I.e. the implementation is independent of the problem dimension and the actual type of elements and shape functions wherever possible. This is done by parametrizing all this information in classes called <em>FEM traits</em>. These trait classes encode all information regarding the dimension of the FE problem, the type of elements and shape functions used and the integrators for the numeric evaluation of the shape functions over the elements. An example of FEM traits for the linear approximation of a 1D FE problem is given below:<p>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>fem_1d_types
  {
  <span class="keyword">public</span>:
    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">std::size_t</a> data_dimension = 1;

    <span class="keyword">typedef</span> Interval1dTransform transform_t;
    <span class="keyword">typedef</span> Linear1dShapeFunction shape_function_t;
    <span class="keyword">typedef</span> IntervalIntegrator&lt;2&gt; integrator_t;
    <span class="keyword">typedef</span> PointIntegrator boundary_integrator_t;
  };
</pre></div><p>
Classes which are designed to be independent of the actual choice of the above parameters are implemented as templates which will be instantiated for specific FEM traits. E.g. the code of the class Assembler does refer to the dimension of the FE problem as <code>fem_types::data_dimension</code> only. The compiler substitutes this expression, when Assembler is instantiated with specified FEM traits, e.g. <code>Assembler&lt;fem_1d_types&gt;</code>.<p>
For a given FE problem the user first selects the right FEM traits class (e.g. <code>fem_2d_square_types</code> for a problem on a 2D image with square elements) and instantiates all components she needs for the FE computation with this trait class. This is shown in the following code example: <div class="fragment"><pre class="fragment">  <a class="code" href="classimaging_1_1Grid.html" title="Provides the data structure and accessor functions for a FE grid.">img::Grid&lt;img::fem_2d_square_types&gt;</a> grid;
  <span class="comment">// construct grid...</span>
  
  SomeEquation&lt;img::fem_2d_square_types&gt; equation;
  <span class="comment">// provide data (i.e. boundary data, right hand side) to the equation...</span>
  
  <a class="code" href="classimaging_1_1Assembler.html" title="Assembles the stiffness matrix and force vector of a FE problem.">img::Assembler&lt;img::fem_2d_square_types&gt;</a>
  img::ublas::compressed_matrix&lt;img::float_t&gt; stiffness_matrix;
  img::ublas::vector&lt;img::float_t&gt; force_vector;
  
  assembler.assemble(equation, grid, stiffness_matrix, force_vector);
  
  <span class="comment">// solve the system of linear equations</span>
</pre></div><p>
This example also illustrates the differentiation into problem-centric and implementation-centric classes we introduced above. Although a complete data structure for the FE grid is provided, the actual construction of the grid depends on the geometry of the problem and has to be done by the user (although she can use helper functions provided by <em>imaging2</em>). Even more manual interaction is required for the equation. The user has to provide a class implementing the equation she wants to solve, and is in addition responsible for providing the equation with the data of the specific problem to solve. Both tasks are clearly problem-centric.<p>
Instead, the class <code>Assembler</code> and its member <code>assemble()</code> is provided by the <em>imaging2</em> library and can be used without modification for any choice of FEM traits. This class is implementation-centric. <hr><h2>Function Documentation</h2>
<a class="anchor" name="gb4b811eb98a133a51801dce05bdcf231"></a><!-- doxytag: member="imaging::average" ref="gb4b811eb98a133a51801dce05bdcf231" args="(const function_t &amp;function, const Grid&lt; fem_types &gt; &amp;grid)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types, class function_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">function_t::value_t imaging::average           </td>
          <td>(</td>
          <td class="paramtype">const function_t &amp;&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Grid&lt; fem_types &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>grid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>#include &lt;<a class="el" href="FeFunctionInterface_8hpp-source.html">fem/FeFunctionInterface.hpp</a>&gt;</code><p>
Computes the average value of <em>function</em> over <em>grid</em>. The parameter <em>function</em> has to implement <a class="el" href="classimaging_1_1FeFunctionInterface.html" title="Abstract base class of FE approximations of functions.">FeFunctionInterface</a>. 
<p>References <a class="el" href="Grid_8hpp-source.html#l00209">imaging::Grid&lt; fem_types &gt;::is_regular()</a>, <a class="el" href="FemKernel_8hpp-source.html#l00090">imaging::FemKernel&lt; fem_types &gt;::lazy_set_element()</a>, <a class="el" href="Grid_8hpp-source.html#l00106">imaging::Grid&lt; fem_types &gt;::n_elements()</a>, <a class="el" href="FemKernel_8hpp-source.html#l00135">imaging::FemKernel&lt; fem_types &gt;::set_element()</a>, and <a class="el" href="FemKernel_8hpp-source.html#l00101">imaging::FemKernel&lt; fem_types &gt;::transform_determinant()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g198d3fac52e398a1a1b89d048f95ebe7"></a><!-- doxytag: member="imaging::circle_grid" ref="g198d3fac52e398a1a1b89d048f95ebe7" args="(float_t radius, std::size_t n_rings, Grid&lt; fem_2d_triangle_types &gt; &amp;grid, ublas::compressed_matrix&lt; float_t &gt; &amp;stiffness_matrix_prototype, std::size_t system_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imaging::circle_grid           </td>
          <td>(</td>
          <td class="paramtype">float_t&nbsp;</td>
          <td class="paramname"> <em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>n_rings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Grid&lt; fem_2d_triangle_types &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ublas::compressed_matrix&lt; float_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>stiffness_matrix_prototype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>system_size</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>#include &lt;fem/utilities.hpp&gt;</code><p>
Constructs a circular <em>grid</em> of <em>radius</em>. The triangular elements are laid out in <em>n_rings</em> rings. The <em>i</em>-th ring contains 4 * <em>i</em> elements. In addition, <em>stiffness_matrix_prototype</em> is resized to the correct size for <em>grid</em>. In case the PDE to be solved is not scalar but a system of equation, the user has to pass the number of equations (<em>system_size</em>) to ensure that <em>stiffness_matrix_prototype</em> is sized correctly. 
<p>References <a class="el" href="fem_2utilities_8cxx-source.html#l00072">imaging::ellipse_grid()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gb469174069f35c09d24bebb7f3219a7b"></a><!-- doxytag: member="imaging::ellipse_grid" ref="gb469174069f35c09d24bebb7f3219a7b" args="(float_t a, float_t b, std::size_t n_rings, Grid&lt; fem_2d_triangle_types &gt; &amp;grid, ublas::compressed_matrix&lt; float_t &gt; &amp;stiffness_matrix_prototype, std::size_t system_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imaging::ellipse_grid           </td>
          <td>(</td>
          <td class="paramtype">float_t&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_t&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>n_rings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Grid&lt; fem_2d_triangle_types &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ublas::compressed_matrix&lt; float_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>stiffness_matrix_prototype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>system_size</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>#include &lt;fem/utilities.hpp&gt;</code><p>
Constructs a elliptic <em>grid</em> with axis of length <em>a</em> and <em>b</em>. The triangular elements are laid out in <em>n_rings</em> rings. The <em>i</em>-th ring contains 4 * <em>i</em> elements. In addition, <em>stiffness_matrix_prototype</em> is resized to the correct size for <em>grid</em>. In case the PDE to be solved is not scalar but a system of equation, the user has to pass the number of equations (<em>system_size</em>) to ensure that <em>stiffness_matrix_prototype</em> is sized correctly. 
<p>References <a class="el" href="core_2utilities_8hpp-source.html#l00046">imaging::max()</a>, <a class="el" href="core_2utilities_8hpp-source.html#l00027">imaging::PI</a>, <a class="el" href="Grid_8hpp-source.html#l00145">imaging::Grid&lt; fem_types &gt;::set_boundary_element()</a>, <a class="el" href="Grid_8hpp-source.html#l00212">imaging::Grid&lt; fem_types &gt;::set_dimensions()</a>, <a class="el" href="Grid_8hpp-source.html#l00142">imaging::Grid&lt; fem_types &gt;::set_global_node_index()</a>, <a class="el" href="Grid_8hpp-source.html#l00136">imaging::Grid&lt; fem_types &gt;::set_global_vertex_index()</a>, and <a class="el" href="Grid_8hpp-source.html#l00121">imaging::Grid&lt; fem_types &gt;::set_vertex()</a>.</p>

<p>Referenced by <a class="el" href="fem_2utilities_8cxx-source.html#l00066">imaging::circle_grid()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gc3637fa06de45896d3fba48aa67dcc79"></a><!-- doxytag: member="imaging::integrate" ref="gc3637fa06de45896d3fba48aa67dcc79" args="(const function_t &amp;function, const Grid&lt; fem_types &gt; &amp;grid)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types, class function_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">function_t::value_t imaging::integrate           </td>
          <td>(</td>
          <td class="paramtype">const function_t &amp;&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Grid&lt; fem_types &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>grid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>#include &lt;<a class="el" href="FeFunctionInterface_8hpp-source.html">fem/FeFunctionInterface.hpp</a>&gt;</code><p>
Integrates <em>function</em> over <em>grid</em>. The parameter <em>function</em> has to implement <a class="el" href="classimaging_1_1FeFunctionInterface.html" title="Abstract base class of FE approximations of functions.">FeFunctionInterface</a>. 
<p>References <a class="el" href="Grid_8hpp-source.html#l00209">imaging::Grid&lt; fem_types &gt;::is_regular()</a>, <a class="el" href="FemKernel_8hpp-source.html#l00090">imaging::FemKernel&lt; fem_types &gt;::lazy_set_element()</a>, <a class="el" href="Grid_8hpp-source.html#l00106">imaging::Grid&lt; fem_types &gt;::n_elements()</a>, <a class="el" href="FemKernel_8hpp-source.html#l00135">imaging::FemKernel&lt; fem_types &gt;::set_element()</a>, and <a class="el" href="FemKernel_8hpp-source.html#l00101">imaging::FemKernel&lt; fem_types &gt;::transform_determinant()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g50adcd56cea88af7e5279de876b387ac"></a><!-- doxytag: member="imaging::maximum" ref="g50adcd56cea88af7e5279de876b387ac" args="(const function_t &amp;function, const Grid&lt; fem_types &gt; &amp;grid)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types, class function_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">function_t::value_t imaging::maximum           </td>
          <td>(</td>
          <td class="paramtype">const function_t &amp;&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Grid&lt; fem_types &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>grid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>#include &lt;<a class="el" href="FeFunctionInterface_8hpp-source.html">fem/FeFunctionInterface.hpp</a>&gt;</code><p>
Computes the maximum of <em>function</em> over the integrator nodes of <em>grid</em>. The parameter <em>function</em> has to implement <a class="el" href="classimaging_1_1FeFunctionInterface.html" title="Abstract base class of FE approximations of functions.">FeFunctionInterface</a>. 
<p>References <a class="el" href="Grid_8hpp-source.html#l00209">imaging::Grid&lt; fem_types &gt;::is_regular()</a>, <a class="el" href="FemKernel_8hpp-source.html#l00090">imaging::FemKernel&lt; fem_types &gt;::lazy_set_element()</a>, <a class="el" href="core_2utilities_8hpp-source.html#l00046">imaging::max()</a>, <a class="el" href="Grid_8hpp-source.html#l00106">imaging::Grid&lt; fem_types &gt;::n_elements()</a>, and <a class="el" href="FemKernel_8hpp-source.html#l00135">imaging::FemKernel&lt; fem_types &gt;::set_element()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ga3b91cabef45ea73dea64ecfeb61dd14"></a><!-- doxytag: member="imaging::minimum" ref="ga3b91cabef45ea73dea64ecfeb61dd14" args="(const function_t &amp;function, const Grid&lt; fem_types &gt; &amp;grid)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types, class function_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">function_t::value_t imaging::minimum           </td>
          <td>(</td>
          <td class="paramtype">const function_t &amp;&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Grid&lt; fem_types &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>grid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>#include &lt;<a class="el" href="FeFunctionInterface_8hpp-source.html">fem/FeFunctionInterface.hpp</a>&gt;</code><p>
Computes the minimum of <em>function</em> over the integrator nodes of <em>grid</em>. The parameter <em>function</em> has to implement <a class="el" href="classimaging_1_1FeFunctionInterface.html" title="Abstract base class of FE approximations of functions.">FeFunctionInterface</a>. 
<p>References <a class="el" href="Grid_8hpp-source.html#l00209">imaging::Grid&lt; fem_types &gt;::is_regular()</a>, <a class="el" href="FemKernel_8hpp-source.html#l00090">imaging::FemKernel&lt; fem_types &gt;::lazy_set_element()</a>, <a class="el" href="core_2utilities_8hpp-source.html#l00053">imaging::min()</a>, <a class="el" href="Grid_8hpp-source.html#l00106">imaging::Grid&lt; fem_types &gt;::n_elements()</a>, and <a class="el" href="FemKernel_8hpp-source.html#l00135">imaging::FemKernel&lt; fem_types &gt;::set_element()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gd27044c294dff15339ef3bb45d59b63f"></a><!-- doxytag: member="imaging::triangulate_shape" ref="gd27044c294dff15339ef3bb45d59b63f" args="(const BoundaryDiscretizer&lt; 2 &gt; &amp;shape_discretizer, float_t max_triangle_area, Grid&lt; fem_2d_triangle_types &gt; &amp;grid, ublas::compressed_matrix&lt; float_t &gt; &amp;stiffness_matrix_prototype, std::size_t system_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imaging::triangulate_shape           </td>
          <td>(</td>
          <td class="paramtype">const BoundaryDiscretizer&lt; 2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>shape_discretizer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_t&nbsp;</td>
          <td class="paramname"> <em>max_triangle_area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Grid&lt; fem_2d_triangle_types &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ublas::compressed_matrix&lt; float_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>stiffness_matrix_prototype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>system_size</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>#include &lt;fem/utilities.hpp&gt;</code><p>
Triangulates an arbitrary, planar shape given by <em>shape_discretizer</em> and computes a <em>grid</em> from the triangulation. The maximum area of each triangle will not exceed <em>max_triangle_area</em>. In addition, <em>stiffness_matrix_prototype</em> is resized to the correct size for <em>grid</em>. In case the PDE to be solved is not scalar but a system of equation, the user has to pass the number of equations (<em>system_size</em>) to ensure that <em>stiffness_matrix_prototype</em> is sized correctly. 
<p>References <a class="el" href="Grid_8hpp-source.html#l00106">imaging::Grid&lt; fem_types &gt;::n_elements()</a>, <a class="el" href="BoundaryDiscretizer_8hpp-source.html#l00085">imaging::BoundaryDiscretizer&lt; N &gt;::n_points()</a>, <a class="el" href="Grid_8hpp-source.html#l00109">imaging::Grid&lt; fem_types &gt;::n_vertices()</a>, <a class="el" href="Grid_8hpp-source.html#l00145">imaging::Grid&lt; fem_types &gt;::set_boundary_element()</a>, <a class="el" href="Grid_8hpp-source.html#l00212">imaging::Grid&lt; fem_types &gt;::set_dimensions()</a>, <a class="el" href="Grid_8hpp-source.html#l00142">imaging::Grid&lt; fem_types &gt;::set_global_node_index()</a>, <a class="el" href="Grid_8hpp-source.html#l00136">imaging::Grid&lt; fem_types &gt;::set_global_vertex_index()</a>, and <a class="el" href="Grid_8hpp-source.html#l00121">imaging::Grid&lt; fem_types &gt;::set_vertex()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gca2d9ab138fbd2ad652842b14b70b211"></a><!-- doxytag: member="imaging::uniform_grid" ref="gca2d9ab138fbd2ad652842b14b70b211" args="(float_t lower_bound, float_t upper_bound, std::size_t n_elements, Grid&lt; fem_1d_types &gt; &amp;grid, ublas::compressed_matrix&lt; float_t &gt; &amp;stiffness_matrix_prototype, std::size_t system_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imaging::uniform_grid           </td>
          <td>(</td>
          <td class="paramtype">float_t&nbsp;</td>
          <td class="paramname"> <em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_t&nbsp;</td>
          <td class="paramname"> <em>upper_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>n_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Grid&lt; fem_1d_types &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ublas::compressed_matrix&lt; float_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>stiffness_matrix_prototype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>system_size</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>#include &lt;fem/utilities.hpp&gt;</code><p>
Constructs a regular <em>grid</em> (i.e. with elements of constant size) on the interval defined by <em>lower_bound</em> and <em>upper_bound</em> for a system of equations. In addition, <em>stiffness_matrix_prototype</em> is resized to the correct size for <em>grid</em>. In case the PDE to be solved is not scalar but a system of equation, the user has to pass the number of equations (<em>system_size</em>) to ensure that <em>stiffness_matrix_prototype</em> is sized correctly. 
<p>References <a class="el" href="Grid_8hpp-source.html#l00145">imaging::Grid&lt; fem_types &gt;::set_boundary_element()</a>, <a class="el" href="Grid_8hpp-source.html#l00212">imaging::Grid&lt; fem_types &gt;::set_dimensions()</a>, <a class="el" href="Grid_8hpp-source.html#l00142">imaging::Grid&lt; fem_types &gt;::set_global_node_index()</a>, <a class="el" href="Grid_8hpp-source.html#l00136">imaging::Grid&lt; fem_types &gt;::set_global_vertex_index()</a>, and <a class="el" href="Grid_8hpp-source.html#l00121">imaging::Grid&lt; fem_types &gt;::set_vertex()</a>.</p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Feb 10 10:01:31 2009 for imaging2 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
