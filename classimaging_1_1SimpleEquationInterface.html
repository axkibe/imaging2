<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>imaging2: imaging::SimpleEquationInterface&lt; fem_types_t &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceimaging.html">imaging</a>::<a class="el" href="classimaging_1_1SimpleEquationInterface.html">SimpleEquationInterface</a>
  </div>
</div>
<div class="contents">
<h1>imaging::SimpleEquationInterface&lt; fem_types_t &gt; Class Template Reference<br>
<small>
[<a class="el" href="group__fem__equation.html">Equations</a>]</small>
</h1><!-- doxytag: class="imaging::SimpleEquationInterface" -->Abstract base class of scalar, elliptic PDEs in divergence form.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="SimpleEquationInterface_8hpp-source.html">SimpleEquationInterface.hpp</a>&gt;</code>
<p>

<p>
<a href="classimaging_1_1SimpleEquationInterface-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1SimpleEquationInterface.html#6e98390779c720e47e96df472f98fc4e">boundary_data_types</a> { <br>
&nbsp;&nbsp;<a class="el" href="classimaging_1_1SimpleEquationInterface.html#6e98390779c720e47e96df472f98fc4e05cdbb5c2bae40466a9d0c73a29c2057">NO_BOUNDARY_DATA</a>, 
<a class="el" href="classimaging_1_1SimpleEquationInterface.html#6e98390779c720e47e96df472f98fc4ed98262100df4c32d5342639c1f4f3525">IMPLICIT_NEUMANN_DATA</a>, 
<a class="el" href="classimaging_1_1SimpleEquationInterface.html#6e98390779c720e47e96df472f98fc4e9b59b779d377f65ac1daaf744676286a">NEUMANN_DATA</a>, 
<a class="el" href="classimaging_1_1SimpleEquationInterface.html#6e98390779c720e47e96df472f98fc4e7823495461a5c152332982d14e15602a">DIRICHLET_DATA</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classimaging_1_1SimpleEquationInterface.html#6e98390779c720e47e96df472f98fc4e8500dc5f4f1767903883d52713c49524">MIXED_DATA</a>
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef fem_types_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1SimpleEquationInterface.html#2da4f294db17ec7fbe5cb0bcb61f9486">fem_types</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__matrix.html">ublas::fixed_matrix</a><br>
&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>, <br>
fem_types::data_dimension, <br>
fem_types::data_dimension &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1SimpleEquationInterface.html#f3a6b7141af8ec8b57f0fcdca8b5dd7c">matrix_coefficient_t</a></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1SimpleEquationInterface.html#6a065739c6edef7e9035214abbcdf120">stiffness_matrix</a> (std::size_t integrator_node, const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; <a class="el" href="classimaging_1_1SimpleEquationInterface.html#2da4f294db17ec7fbe5cb0bcb61f9486">fem_types</a> &gt; &amp;kernel, <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__matrix.html">matrix_coefficient_t</a> &amp;A, <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">ublas::fixed_vector</a>&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>, fem_types::data_dimension &gt; &amp;a, <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">ublas::fixed_vector</a>&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>, fem_types::data_dimension &gt; &amp;b, <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &amp;c) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1SimpleEquationInterface.html#c863bd19a9becb17e0f46e0d1f502d11">force_vector</a> (std::size_t integrator_node, const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; <a class="el" href="classimaging_1_1SimpleEquationInterface.html#2da4f294db17ec7fbe5cb0bcb61f9486">fem_types</a> &gt; &amp;kernel, <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &amp;f, <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">ublas::fixed_vector</a>&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>, fem_types::data_dimension &gt; &amp;g) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1SimpleEquationInterface.html#52018255619639454d618b43aae24736">stiffness_matrix_at_boundary</a> (std::size_t integrator_node, const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; <a class="el" href="classimaging_1_1SimpleEquationInterface.html#2da4f294db17ec7fbe5cb0bcb61f9486">fem_types</a> &gt; &amp;kernel, <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &amp;h) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1SimpleEquationInterface.html#99e6368b226d6e69cf23b0ccd2b1ccc4">force_vector_at_boundary</a> (std::size_t integrator_node, const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; <a class="el" href="classimaging_1_1SimpleEquationInterface.html#2da4f294db17ec7fbe5cb0bcb61f9486">fem_types</a> &gt; &amp;kernel, <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &amp;v) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1SimpleEquationInterface.html#25ce82ef09f07d93e431ae27fcd99e84">sanity_check_stiffness_matrix</a> (const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; <a class="el" href="classimaging_1_1SimpleEquationInterface.html#2da4f294db17ec7fbe5cb0bcb61f9486">fem_types</a> &gt; &amp;kernel, std::string &amp;error_message) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1SimpleEquationInterface.html#f8ededab332800a6b6bb38fcf7646987">sanity_check_force_vector</a> (const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; <a class="el" href="classimaging_1_1SimpleEquationInterface.html#2da4f294db17ec7fbe5cb0bcb61f9486">fem_types</a> &gt; &amp;kernel, std::string &amp;error_message) const </td></tr>

<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1SimpleEquationInterface.html#b53090346b28044add0b4787ac0a746b">a_active</a> = true</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1SimpleEquationInterface.html#298b95b7fa2eaaffd68b96ce7805e137">b_active</a> = true</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1SimpleEquationInterface.html#667b200b942a4159e1d9b03c6a6e0533">c_active</a> = true</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1SimpleEquationInterface.html#377f80a1c17bcd0c3872a0bcebfb87db">f_active</a> = true</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1SimpleEquationInterface.html#eca56c9c50243ac02c0c49bcdc5def02">g_active</a> = true</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1SimpleEquationInterface.html#ca9b4a4d0e6ef514597c3e3ba89645ae">boundary_data_type</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class fem_types_t&gt;<br>
 class imaging::SimpleEquationInterface&lt; fem_types_t &gt;</h3>

Abstract base class of scalar, elliptic PDEs in divergence form. 
<p>
Derive this interface to solve a scalar, elliptic PDE in divergence form, i.e. <p class="formulaDsp">
<img class="formulaDsp" alt="\[ - \nabla \cdot (A \nabla u + \vec a u ) + \vec b \cdot \nabla u + c u = f - \nabla \cdot \vec g \quad \textrm{on} \quad \Omega\,. \]" src="form_41.png">
<p>
 The weak formulation of the above problem reads as <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_\Omega (A \nabla u + \vec a u ) \nabla \phi + \int_\Omega \vec b \cdot \nabla u \phi + \int_\Omega c u \phi = \int_\Omega f \phi + \int_\Omega \vec g \nabla \phi \,, \]" src="form_42.png">
<p>
 for a test function <img class="formulaInl" alt="$\phi$" src="form_43.png"> <em>with</em> compact support.<p>
Depending on the boundary conditions (i.e. on the value of the constant <code>boundary_data_type</code> ), this class implements five different weak formulations of boundary value problems.<p>
<ul>
<li><code> boundary_data_type == NO_BOUNDARY_DATA </code> <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_\Omega (A \nabla u + \vec a u ) \nabla \psi + \int_\Omega \vec b \cdot \nabla u \psi + \int_\Omega c u \psi = \int_\Omega f \psi + \int_\Omega \vec g \nabla \psi \,, \]" src="form_44.png">
<p>
 for a test function <img class="formulaInl" alt="$\psi$" src="form_45.png"> (<em>without</em> compact support). This implies the boundary conditions <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial}{\partial \vec n}(A \nabla u + \vec a u) = 0 \quad \textrm{on} \quad \partial \Omega\,. \]" src="form_46.png">
<p>
</li></ul>
<p>
<ul>
<li><code> boundary_data_type == IMPLICIT_NEUMANN_DATA </code> <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_\Omega (A \nabla u + \vec a u ) \nabla \psi + \int_\Omega \vec b \cdot \nabla u \psi + \int_\Omega c u \psi = \int_\Omega f \psi + \int_\Omega \vec g \nabla \psi - \int_{\partial \Omega} v \psi \,, \]" src="form_47.png">
<p>
 for a test function <img class="formulaInl" alt="$\psi$" src="form_45.png"> (<em>without</em> compact support). This implies the boundary conditions <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial}{\partial \vec n}(A \nabla u + \vec a u) = v \quad \textrm{on} \quad \partial \Omega\,. \]" src="form_48.png">
<p>
</li></ul>
<p>
<ul>
<li><code> boundary_data_type == NEUMANN_DATA </code> <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_\Omega (A \nabla u + \vec a u ) \nabla \phi + \int_\Omega \vec b \cdot \nabla u \phi + \int_\Omega c u \phi = \int_\Omega f \phi + \int_\Omega \vec g \nabla \phi \,, \]" src="form_42.png">
<p>
 for a test function <img class="formulaInl" alt="$\phi$" src="form_43.png"> (<em>with</em> compact support) and <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_{\partial \Omega} \frac{\partial u}{\partial \vec n} \psi = \int_{\partial \Omega} v \psi\,, \]" src="form_49.png">
<p>
 for a test function <img class="formulaInl" alt="$\psi$" src="form_45.png"> (<em>without</em> compact support). This implies the boundary conditions <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial u}{\partial \vec n} = v \quad \textrm{on} \quad \partial \Omega\,. \]" src="form_50.png">
<p>
</li></ul>
<p>
<ul>
<li><code> boundary_data_type == DIRICHLET_DATA </code> <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_\Omega (A \nabla u + \vec a u ) \nabla \phi + \int_\Omega \vec b \cdot \nabla u \phi + \int_\Omega c u \phi = \int_\Omega f \phi + \int_\Omega \vec g \nabla \phi \,, \]" src="form_42.png">
<p>
 for a test function <img class="formulaInl" alt="$\phi$" src="form_43.png"> (<em>with</em> compact support) and <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_{\partial \Omega} u \psi = \int_{\partial \Omega} v \psi\,, \]" src="form_51.png">
<p>
 for a test function <img class="formulaInl" alt="$\psi$" src="form_45.png"> (<em>without</em> compact support). This implies the boundary conditions <p class="formulaDsp">
<img class="formulaDsp" alt="\[ u = v \quad \textrm{on} \quad \partial \Omega\,. \]" src="form_52.png">
<p>
</li></ul>
<p>
<ul>
<li><code> boundary_data_type == MIXED_DATA </code> <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_\Omega (A \nabla u + \vec a u ) \nabla \phi + \int_\Omega \vec b \cdot \nabla u \phi + \int_\Omega c u \phi = \int_\Omega f \phi + \int_\Omega \vec g \nabla \phi \,, \]" src="form_42.png">
<p>
 for a test function <img class="formulaInl" alt="$\phi$" src="form_43.png"> (<em>with</em> compact support) and <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_{\partial \Omega} \frac{\partial u}{\partial \vec n} \psi + \int_{\partial \Omega} h u \psi = \int_{\partial \Omega} v \psi\,, \]" src="form_53.png">
<p>
 for a test function <img class="formulaInl" alt="$\psi$" src="form_45.png"> (<em>without</em> compact support). This implies the boundary conditions <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial u}{\partial \vec n} + h u = v \quad \textrm{on} \quad \partial \Omega\,. \]" src="form_54.png">
<p>
 </li></ul>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="2da4f294db17ec7fbe5cb0bcb61f9486"></a><!-- doxytag: member="imaging::SimpleEquationInterface::fem_types" ref="2da4f294db17ec7fbe5cb0bcb61f9486" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef fem_types_t <a class="el" href="classimaging_1_1SimpleEquationInterface.html">imaging::SimpleEquationInterface</a>&lt; fem_types_t &gt;::<a class="el" href="classimaging_1_1SimpleEquationInterface.html#2da4f294db17ec7fbe5cb0bcb61f9486">fem_types</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The <em>fem_types</em> for which this class template was instantiated. 
</div>
</div><p>
<a class="anchor" name="f3a6b7141af8ec8b57f0fcdca8b5dd7c"></a><!-- doxytag: member="imaging::SimpleEquationInterface::matrix_coefficient_t" ref="f3a6b7141af8ec8b57f0fcdca8b5dd7c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__matrix.html">ublas::fixed_matrix</a>&lt;<a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>, fem_types::data_dimension, fem_types::data_dimension&gt; <a class="el" href="classimaging_1_1SimpleEquationInterface.html">imaging::SimpleEquationInterface</a>&lt; fem_types_t &gt;::<a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__matrix.html">matrix_coefficient_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Defines the type of matrix as passed to A(). If A() returns a diagonal matrix choosing an appropriate type to store this matrix might yield a speed-up (in particular in higher dimensions; in the plane the difference will most probably neglible). 
<p>Reimplemented in <a class="el" href="classimaging_1_1DiffusionStep.html#d59a4af3badb1ac7a30b35052639a3fe">imaging::DiffusionStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1GeodesicActiveContourStep.html#6885049f75b3901a529f109906714e1a">imaging::GeodesicActiveContourStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1McmStep.html#6f77eee5c33c7fda8cd4f2a9170d37f3">imaging::McmStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1PoissonEquation.html#c3f7c72b61f54d65f36415fc06c8fe09">imaging::PoissonEquation&lt; fem_types &gt;</a>, and <a class="el" href="classimaging_1_1TvFlowStep.html#d817e9b42e49524454a1d4dd76bfff6d">imaging::TvFlowStep&lt; fem_types &gt;</a>.</p>

</div>
</div><p>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="6e98390779c720e47e96df472f98fc4e"></a><!-- doxytag: member="imaging::SimpleEquationInterface::boundary_data_types" ref="6e98390779c720e47e96df472f98fc4e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classimaging_1_1SimpleEquationInterface.html#6e98390779c720e47e96df472f98fc4e">imaging::SimpleEquationInterface::boundary_data_types</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Different kinds of boundary data. A detailed description is given in the general part of the class documentation. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="6e98390779c720e47e96df472f98fc4e05cdbb5c2bae40466a9d0c73a29c2057"></a><!-- doxytag: member="NO_BOUNDARY_DATA" ref="6e98390779c720e47e96df472f98fc4e05cdbb5c2bae40466a9d0c73a29c2057" args="" -->NO_BOUNDARY_DATA</em>&nbsp;</td><td>
No boundary data. This implies a homogenous condition depending on the equation. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="6e98390779c720e47e96df472f98fc4ed98262100df4c32d5342639c1f4f3525"></a><!-- doxytag: member="IMPLICIT_NEUMANN_DATA" ref="6e98390779c720e47e96df472f98fc4ed98262100df4c32d5342639c1f4f3525" args="" -->IMPLICIT_NEUMANN_DATA</em>&nbsp;</td><td>
The same as <em>NO_BOUNDARY_DATA</em>, but with a possible non-homogenous condition. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="6e98390779c720e47e96df472f98fc4e9b59b779d377f65ac1daaf744676286a"></a><!-- doxytag: member="NEUMANN_DATA" ref="6e98390779c720e47e96df472f98fc4e9b59b779d377f65ac1daaf744676286a" args="" -->NEUMANN_DATA</em>&nbsp;</td><td>
Neumann conditions. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="6e98390779c720e47e96df472f98fc4e7823495461a5c152332982d14e15602a"></a><!-- doxytag: member="DIRICHLET_DATA" ref="6e98390779c720e47e96df472f98fc4e7823495461a5c152332982d14e15602a" args="" -->DIRICHLET_DATA</em>&nbsp;</td><td>
Dirichlet conditions. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="6e98390779c720e47e96df472f98fc4e8500dc5f4f1767903883d52713c49524"></a><!-- doxytag: member="MIXED_DATA" ref="6e98390779c720e47e96df472f98fc4e8500dc5f4f1767903883d52713c49524" args="" -->MIXED_DATA</em>&nbsp;</td><td>
Robin conditions. </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="6a065739c6edef7e9035214abbcdf120"></a><!-- doxytag: member="imaging::SimpleEquationInterface::stiffness_matrix" ref="6a065739c6edef7e9035214abbcdf120" args="(std::size_t integrator_node, const FemKernel&lt; fem_types &gt; &amp;kernel, matrix_coefficient_t &amp;A, ublas::fixed_vector&lt; float_t, fem_types::data_dimension &gt; &amp;a, ublas::fixed_vector&lt; float_t, fem_types::data_dimension &gt; &amp;b, float_t &amp;c) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classimaging_1_1SimpleEquationInterface.html">imaging::SimpleEquationInterface</a>&lt; fem_types_t &gt;::stiffness_matrix           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>integrator_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; <a class="el" href="classimaging_1_1SimpleEquationInterface.html#2da4f294db17ec7fbe5cb0bcb61f9486">fem_types</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__matrix.html">matrix_coefficient_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">ublas::fixed_vector</a>&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>, fem_types::data_dimension &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">ublas::fixed_vector</a>&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>, fem_types::data_dimension &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Evaluates <img class="formulaInl" alt="$A$" src="form_57.png">, <img class="formulaInl" alt="$a$" src="form_5.png">, <img class="formulaInl" alt="$b$" src="form_55.png"> and <img class="formulaInl" alt="$c$" src="form_56.png"> in <em>integrator_node</em> on the current element of <em>kernel</em>.<p>
As <em>kernel</em> is set to the current element, in the implementation of this function all relevant values of the shape functions and the element transform can be retrieved from <em>kernel</em> via <em>integrator_node</em>. One can also obtain the FE grid from the kernel (<a class="el" href="classimaging_1_1FemKernel.html#3a0ac5880414db3603a76a358e8d32bd">FemKernel::grid()</a>) and use its interpolation methods (passing the already correctly initialized <em>kernel</em> to them). 
<p>Reimplemented in <a class="el" href="classimaging_1_1DiffusionStep.html#d084b41bf0666f035dd1ec6240696412">imaging::DiffusionStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1GeodesicActiveContourStep.html#18ba339a93353f35fb98fd2107180527">imaging::GeodesicActiveContourStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1McmStep.html#c3e2aa0614d93bb8b881f08131893002">imaging::McmStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1PoissonEquation.html#1026bf857bf8a3f050e8c0c5cf313fc4">imaging::PoissonEquation&lt; fem_types &gt;</a>, and <a class="el" href="classimaging_1_1TvFlowStep.html#8ecb89c0aa464caadf93912f17e8b2ab">imaging::TvFlowStep&lt; fem_types &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="c863bd19a9becb17e0f46e0d1f502d11"></a><!-- doxytag: member="imaging::SimpleEquationInterface::force_vector" ref="c863bd19a9becb17e0f46e0d1f502d11" args="(std::size_t integrator_node, const FemKernel&lt; fem_types &gt; &amp;kernel, float_t &amp;f, ublas::fixed_vector&lt; float_t, fem_types::data_dimension &gt; &amp;g) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classimaging_1_1SimpleEquationInterface.html">imaging::SimpleEquationInterface</a>&lt; fem_types_t &gt;::force_vector           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>integrator_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; <a class="el" href="classimaging_1_1SimpleEquationInterface.html#2da4f294db17ec7fbe5cb0bcb61f9486">fem_types</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">ublas::fixed_vector</a>&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>, fem_types::data_dimension &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>g</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Evaluates <img class="formulaInl" alt="$f$" src="form_22.png"> and <img class="formulaInl" alt="$g$" src="form_31.png"> in <em>integrator_node</em> on the current element of <em>kernel</em>.<p>
As <em>kernel</em> is set to the current element, in the implementation of this function all relevant values of the shape functions and the element transform can be retrieved from <em>kernel</em> via <em>integrator_node</em>. One can also obtain the FE grid from the kernel (<a class="el" href="classimaging_1_1FemKernel.html#3a0ac5880414db3603a76a358e8d32bd">FemKernel::grid()</a>) and use its interpolation methods (passing the already correctly initialized <em>kernel</em> to them). 
<p>Reimplemented in <a class="el" href="classimaging_1_1DiffusionStep.html#e91ce6d65d0d4aee60c47c1acb6d13e2">imaging::DiffusionStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1GeodesicActiveContourStep.html#8e1f8cbe23c1208cdfef601953e6263b">imaging::GeodesicActiveContourStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1McmStep.html#b6f1d896a5028910449444109e40a391">imaging::McmStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1PoissonEquation.html#27d549cda5e09d32183286c839978c50">imaging::PoissonEquation&lt; fem_types &gt;</a>, and <a class="el" href="classimaging_1_1TvFlowStep.html#e1971168bbb50e8d4f6194e1d40d544f">imaging::TvFlowStep&lt; fem_types &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="52018255619639454d618b43aae24736"></a><!-- doxytag: member="imaging::SimpleEquationInterface::stiffness_matrix_at_boundary" ref="52018255619639454d618b43aae24736" args="(std::size_t integrator_node, const FemKernel&lt; fem_types &gt; &amp;kernel, float_t &amp;h) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classimaging_1_1SimpleEquationInterface.html">imaging::SimpleEquationInterface</a>&lt; fem_types_t &gt;::stiffness_matrix_at_boundary           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>integrator_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; <a class="el" href="classimaging_1_1SimpleEquationInterface.html#2da4f294db17ec7fbe5cb0bcb61f9486">fem_types</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>h</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Evaluates <img class="formulaInl" alt="$h$" src="form_58.png"> in <em>integrator_node</em> on the current element of <em>kernel</em>.<p>
As <em>kernel</em> is set to the current element, in the implementation of this function all relevant values of the shape functions and the element transform can be retrieved from <em>kernel</em> via <em>integrator_node</em>. One can also obtain the FE grid from the kernel (<a class="el" href="classimaging_1_1FemKernel.html#3a0ac5880414db3603a76a358e8d32bd">FemKernel::grid()</a>) and use its interpolation methods (passing the already correctly initialized <em>kernel</em> to them). 
</div>
</div><p>
<a class="anchor" name="99e6368b226d6e69cf23b0ccd2b1ccc4"></a><!-- doxytag: member="imaging::SimpleEquationInterface::force_vector_at_boundary" ref="99e6368b226d6e69cf23b0ccd2b1ccc4" args="(std::size_t integrator_node, const FemKernel&lt; fem_types &gt; &amp;kernel, float_t &amp;v) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classimaging_1_1SimpleEquationInterface.html">imaging::SimpleEquationInterface</a>&lt; fem_types_t &gt;::force_vector_at_boundary           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>integrator_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; <a class="el" href="classimaging_1_1SimpleEquationInterface.html#2da4f294db17ec7fbe5cb0bcb61f9486">fem_types</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Evaluates <img class="formulaInl" alt="$v$" src="form_40.png"> in <em>integrator_node</em> on the current element of <em>kernel</em>.<p>
As <em>kernel</em> is set to the current element, in the implementation of this function all relevant values of the shape functions and the element transform can be retrieved from <em>kernel</em> via <em>integrator_node</em>. One can also obtain the FE grid from the kernel (<a class="el" href="classimaging_1_1FemKernel.html#3a0ac5880414db3603a76a358e8d32bd">FemKernel::grid()</a>) and use its interpolation methods (passing the already correctly initialized <em>kernel</em> to them). 
<p>Reimplemented in <a class="el" href="classimaging_1_1PoissonEquation.html#eedb5079502eccb77f891fa030e0323d">imaging::PoissonEquation&lt; fem_types &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="25ce82ef09f07d93e431ae27fcd99e84"></a><!-- doxytag: member="imaging::SimpleEquationInterface::sanity_check_stiffness_matrix" ref="25ce82ef09f07d93e431ae27fcd99e84" args="(const FemKernel&lt; fem_types &gt; &amp;kernel, std::string &amp;error_message) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classimaging_1_1SimpleEquationInterface.html">imaging::SimpleEquationInterface</a>&lt; fem_types_t &gt;::sanity_check_stiffness_matrix           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; <a class="el" href="classimaging_1_1SimpleEquationInterface.html#2da4f294db17ec7fbe5cb0bcb61f9486">fem_types</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>error_message</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if the dimension of the data corresponds to the dimension of the grid stored in <em>kernel</em> for the assembly of the stiffness matrix.<p>
This function is called by the assemble routine right before the assembly of the stiffness matrix. It should return <em>false</em> if data which is necessary for the assembly of the stiffness matrix is still missing. Otherwise, return <em>true</em>; 
<p>Reimplemented in <a class="el" href="classimaging_1_1DiffusionStep.html#cdfe0ba85d1d65e4d848515c5fb7ec9d">imaging::DiffusionStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1GeodesicActiveContourStep.html#d69110ec11dd1fca43916637ea6c6230">imaging::GeodesicActiveContourStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1McmStep.html#7f9c1e67db321b902fd8f6be7d48cf48">imaging::McmStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1PoissonEquation.html#1253b160919b3a525a04b17d3aa468cf">imaging::PoissonEquation&lt; fem_types &gt;</a>, and <a class="el" href="classimaging_1_1TvFlowStep.html#656524e9780d8a8572a1dffdae79ac8f">imaging::TvFlowStep&lt; fem_types &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="f8ededab332800a6b6bb38fcf7646987"></a><!-- doxytag: member="imaging::SimpleEquationInterface::sanity_check_force_vector" ref="f8ededab332800a6b6bb38fcf7646987" args="(const FemKernel&lt; fem_types &gt; &amp;kernel, std::string &amp;error_message) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classimaging_1_1SimpleEquationInterface.html">imaging::SimpleEquationInterface</a>&lt; fem_types_t &gt;::sanity_check_force_vector           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; <a class="el" href="classimaging_1_1SimpleEquationInterface.html#2da4f294db17ec7fbe5cb0bcb61f9486">fem_types</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>error_message</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if the dimension of the data corresponds to the dimension of the grid stored in <em>kernel</em> for the assembly of the force vector.<p>
This function is called by the assemble routine right before the assembly of the force vector. It should return <em>false</em> if data which is necessary for the assembly of the force vector is still missing. Otherwise, return <em>true</em>; 
<p>Reimplemented in <a class="el" href="classimaging_1_1DiffusionStep.html#56a3a04eebe18607339c595fe4a8db00">imaging::DiffusionStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1GeodesicActiveContourStep.html#0c729ed2c4b370c2f78e29ba68ccdbc3">imaging::GeodesicActiveContourStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1McmStep.html#fd417a4f9c3c7617f6539a7207675b13">imaging::McmStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1PoissonEquation.html#09ae9e82681ca6a35e5de638707a7ca3">imaging::PoissonEquation&lt; fem_types &gt;</a>, and <a class="el" href="classimaging_1_1TvFlowStep.html#54a9595eece428e4560fa519f8675ba9">imaging::TvFlowStep&lt; fem_types &gt;</a>.</p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="b53090346b28044add0b4787ac0a746b"></a><!-- doxytag: member="imaging::SimpleEquationInterface::a_active" ref="b53090346b28044add0b4787ac0a746b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classimaging_1_1SimpleEquationInterface.html">imaging::SimpleEquationInterface</a>&lt; fem_types_t &gt;::<a class="el" href="classimaging_1_1SimpleEquationInterface.html#b53090346b28044add0b4787ac0a746b">a_active</a> = true<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Must be set to <em>true</em> if <img class="formulaInl" alt="$a$" src="form_5.png"> can be non-zero. If it is <em>false</em>, <img class="formulaInl" alt="$a$" src="form_5.png"> will not be evaluated in the assembly functions to save computation time. 
<p>Reimplemented in <a class="el" href="classimaging_1_1DiffusionStep.html#ba93c5e8960bf36967241f4b76a06368">imaging::DiffusionStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1GeodesicActiveContourStep.html#f9a63e433d351c1ce947044357e091d6">imaging::GeodesicActiveContourStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1McmStep.html#51a91a590a248d0029455c6539d0679c">imaging::McmStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1PoissonEquation.html#19af6fec53a49b6d4b9aca22daf3dd16">imaging::PoissonEquation&lt; fem_types &gt;</a>, and <a class="el" href="classimaging_1_1TvFlowStep.html#f90a7b750e148c812fe2aa0582f7a7c1">imaging::TvFlowStep&lt; fem_types &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="298b95b7fa2eaaffd68b96ce7805e137"></a><!-- doxytag: member="imaging::SimpleEquationInterface::b_active" ref="298b95b7fa2eaaffd68b96ce7805e137" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classimaging_1_1SimpleEquationInterface.html">imaging::SimpleEquationInterface</a>&lt; fem_types_t &gt;::<a class="el" href="classimaging_1_1SimpleEquationInterface.html#298b95b7fa2eaaffd68b96ce7805e137">b_active</a> = true<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Must be set to <em>true</em> if <img class="formulaInl" alt="$b$" src="form_55.png"> can be non-zero. If it is <em>false</em>, <img class="formulaInl" alt="$b$" src="form_55.png"> will not be evaluated in the assembly functions to save computation time. 
<p>Reimplemented in <a class="el" href="classimaging_1_1DiffusionStep.html#8e128931e08d4e0486b751f8afd4777b">imaging::DiffusionStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1GeodesicActiveContourStep.html#b0433e44e681c34416eb5a93accd9b92">imaging::GeodesicActiveContourStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1McmStep.html#43dcf5763a211a25b3004e56bf1b46ee">imaging::McmStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1PoissonEquation.html#898c4dfaa8f4ef51e292ec590bcdf303">imaging::PoissonEquation&lt; fem_types &gt;</a>, and <a class="el" href="classimaging_1_1TvFlowStep.html#a6156c890014d0857f121f190e8b0b21">imaging::TvFlowStep&lt; fem_types &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="667b200b942a4159e1d9b03c6a6e0533"></a><!-- doxytag: member="imaging::SimpleEquationInterface::c_active" ref="667b200b942a4159e1d9b03c6a6e0533" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classimaging_1_1SimpleEquationInterface.html">imaging::SimpleEquationInterface</a>&lt; fem_types_t &gt;::<a class="el" href="classimaging_1_1SimpleEquationInterface.html#667b200b942a4159e1d9b03c6a6e0533">c_active</a> = true<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Must be set to <em>true</em> if <img class="formulaInl" alt="$c$" src="form_56.png"> can be non-zero. If it is <em>false</em>, <img class="formulaInl" alt="$c$" src="form_56.png"> will not be evaluated in the assembly functions to save computation time. 
<p>Reimplemented in <a class="el" href="classimaging_1_1DiffusionStep.html#40e6ec3857a37a029acc972e61d524e0">imaging::DiffusionStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1GeodesicActiveContourStep.html#e7e95cbfb7436ab1889682f35ec9667a">imaging::GeodesicActiveContourStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1McmStep.html#6cf9c0f0d6d78808719c2cbd4a44a0c7">imaging::McmStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1PoissonEquation.html#1c69fa52630afbe763c803cb36c1e1bc">imaging::PoissonEquation&lt; fem_types &gt;</a>, and <a class="el" href="classimaging_1_1TvFlowStep.html#0e0aea0d3381d1c87b770f7222887437">imaging::TvFlowStep&lt; fem_types &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="377f80a1c17bcd0c3872a0bcebfb87db"></a><!-- doxytag: member="imaging::SimpleEquationInterface::f_active" ref="377f80a1c17bcd0c3872a0bcebfb87db" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classimaging_1_1SimpleEquationInterface.html">imaging::SimpleEquationInterface</a>&lt; fem_types_t &gt;::<a class="el" href="classimaging_1_1SimpleEquationInterface.html#377f80a1c17bcd0c3872a0bcebfb87db">f_active</a> = true<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Must be set to <em>true</em> if <img class="formulaInl" alt="$f$" src="form_22.png"> can be non-zero. If it is <em>false</em>, <img class="formulaInl" alt="$f$" src="form_22.png"> will not be evaluated in the assembly functions to save computation time. 
<p>Reimplemented in <a class="el" href="classimaging_1_1DiffusionStep.html#9d192abcafa37ddb433dc844df2d5fde">imaging::DiffusionStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1GeodesicActiveContourStep.html#169670ec37b3a1b8875a4fada2c40c2e">imaging::GeodesicActiveContourStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1McmStep.html#670307e0ef3d9484db0a2d4a7cbf36b6">imaging::McmStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1PoissonEquation.html#beaab1e07e4bd07e49c6603aea1399bd">imaging::PoissonEquation&lt; fem_types &gt;</a>, and <a class="el" href="classimaging_1_1TvFlowStep.html#ed45eb272d2cfff57b89c86b2ab73fde">imaging::TvFlowStep&lt; fem_types &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="eca56c9c50243ac02c0c49bcdc5def02"></a><!-- doxytag: member="imaging::SimpleEquationInterface::g_active" ref="eca56c9c50243ac02c0c49bcdc5def02" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classimaging_1_1SimpleEquationInterface.html">imaging::SimpleEquationInterface</a>&lt; fem_types_t &gt;::<a class="el" href="classimaging_1_1SimpleEquationInterface.html#eca56c9c50243ac02c0c49bcdc5def02">g_active</a> = true<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Must be set to <em>true</em> if <img class="formulaInl" alt="$g$" src="form_31.png"> can be non-zero. If it is <em>false</em>, <img class="formulaInl" alt="$g$" src="form_31.png"> will not be evaluated in the assembly functions to save computation time. 
<p>Reimplemented in <a class="el" href="classimaging_1_1DiffusionStep.html#5824f0614e5a918bb44b5d45060bfd98">imaging::DiffusionStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1GeodesicActiveContourStep.html#015c1bf01eb9ae2b7c0be039ed5b3611">imaging::GeodesicActiveContourStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1McmStep.html#d40b4d678d74c890737f77dc7b506bdb">imaging::McmStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1PoissonEquation.html#487e60e134622dc472cfc0ac4fb15e64">imaging::PoissonEquation&lt; fem_types &gt;</a>, and <a class="el" href="classimaging_1_1TvFlowStep.html#77567a097bbdbb87be40add5a952fd3f">imaging::TvFlowStep&lt; fem_types &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="ca9b4a4d0e6ef514597c3e3ba89645ae"></a><!-- doxytag: member="imaging::SimpleEquationInterface::boundary_data_type" ref="ca9b4a4d0e6ef514597c3e3ba89645ae" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> <a class="el" href="classimaging_1_1SimpleEquationInterface.html">imaging::SimpleEquationInterface</a>&lt; fem_types_t &gt;::<a class="el" href="classimaging_1_1SimpleEquationInterface.html#ca9b4a4d0e6ef514597c3e3ba89645ae">boundary_data_type</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The type of boundary conditions for this equation as defined in <a class="el" href="classimaging_1_1SimpleEquationInterface.html#6e98390779c720e47e96df472f98fc4e">SimpleEquationInterface::boundary_data_types</a>. 
<p>Reimplemented in <a class="el" href="classimaging_1_1DiffusionStep.html#4d853fa7c5cadcbe116aeac080dbdac0">imaging::DiffusionStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1GeodesicActiveContourStep.html#1c33e28fcb7fd410b7f9e1161e0de6c5">imaging::GeodesicActiveContourStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1McmStep.html#7d1c07aa62cb4417a56bc32a75822ab1">imaging::McmStep&lt; fem_types &gt;</a>, <a class="el" href="classimaging_1_1PoissonEquation.html#7734580f15ed338577e1bea1630ca09f">imaging::PoissonEquation&lt; fem_types &gt;</a>, and <a class="el" href="classimaging_1_1TvFlowStep.html#8001c958f8583e532e6185aa1a3fa491">imaging::TvFlowStep&lt; fem_types &gt;</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>imaging2/fem/equation/<a class="el" href="SimpleEquationInterface_8hpp-source.html">SimpleEquationInterface.hpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Feb 10 10:01:31 2009 for imaging2 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
