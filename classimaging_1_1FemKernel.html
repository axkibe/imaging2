<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>imaging2: imaging::FemKernel&lt; fem_types &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceimaging.html">imaging</a>::<a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>
  </div>
</div>
<div class="contents">
<h1>imaging::FemKernel&lt; fem_types &gt; Class Template Reference<br>
<small>
[<a class="el" href="group__fem.html">Finite Element Module</a>]</small>
</h1><!-- doxytag: class="imaging::FemKernel" -->Computes the values of the shape functions and the element transformation in the integration nodes.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="FemKernel_8hpp-source.html">FemKernel.hpp</a>&gt;</code>
<p>

<p>
<a href="classimaging_1_1FemKernel-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1FemKernel.html#0784d605f938b3dfc99192465d76b6dc">FemKernel</a> (const <a class="el" href="classimaging_1_1Grid.html">Grid</a>&lt; fem_types &gt; &amp;grid)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classimaging_1_1Grid.html">Grid</a>&lt; fem_types &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1FemKernel.html#3a0ac5880414db3603a76a358e8d32bd">grid</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1FemKernel.html#809e84d34ff6875978570d112210ead3">set_element</a> (std::size_t element)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1FemKernel.html#8af32977610d179d188bcf137035a9e6">set_boundary_element</a> (std::size_t boundary_element)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1FemKernel.html#19c6e5df6f1325cf605e71011afb20ac">lazy_set_element</a> (std::size_t element)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1FemKernel.html#e1f68b1ef8f507c591ef0f4bdba42806">shape_value</a> (std::size_t integrator_node, std::size_t element_node) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">ublas::fixed_vector</a><br>
&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>, <br>
fem_types::data_dimension &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1FemKernel.html#8c0eedb686a8ed23245fe4fd47f697a7">shape_gradient</a> (std::size_t integrator_node, std::size_t element_node) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1FemKernel.html#35d900808ae8e7441a93aaf7335b92a4">transform_determinant</a> (std::size_t integrator_node) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1FemKernel.html#f3d0c86ea00cff4de63e390b5f3f4700">shape_boundary_value</a> (std::size_t integrator_node, std::size_t element_node) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1FemKernel.html#3ad8cd514cf6f0ab06448e1e289666e3">shape_boundary_derivative</a> (std::size_t integrator_node, std::size_t element_node) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1FemKernel.html#8087e3cb00a824dfc2614d13175ef800">boundary_transform_determinant</a> (std::size_t integrator_node) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">ublas::fixed_vector</a><br>
&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>, <br>
fem_types::data_dimension &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1FemKernel.html#a6227854349e3feb74871eae3fce5593">boundary_normal</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1FemKernel.html#8e37e706ffa692206e0c2153c7cb9de5">current_element</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1FemKernel.html#9b2e2924edb7cc5f3c00166308493f7e">current_boundary_element</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1FemKernel.html#51eed7c8f1585b7dabbb04e3fc1cce05">is_boundary_node</a> (std::size_t element_node) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">ublas::fixed_vector</a><br>
&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>, <br>
fem_types::data_dimension &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1FemKernel.html#1b04fbafeabbc6d3d8a8b45d169473f8">boundary_normal_at_node</a> (std::size_t element_node) const </td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class fem_types&gt;<br>
 class imaging::FemKernel&lt; fem_types &gt;</h3>

Computes the values of the shape functions and the element transformation in the integration nodes. 
<p>
<a class="el" href="classimaging_1_1FemKernel.html" title="Computes the values of the shape functions and the element transformation in the...">FemKernel</a> is a class which is used to evaluate functions in the integration nodes on a given element. The integrator, the shape function and the element type is specified by the template parameter <em>fem_types</em>. If a <a class="el" href="classimaging_1_1FemKernel.html" title="Computes the values of the shape functions and the element transformation in the...">FemKernel</a> is set to an element by calling <a class="el" href="classimaging_1_1FemKernel.html#809e84d34ff6875978570d112210ead3">set_element()</a> or <a class="el" href="classimaging_1_1FemKernel.html#8af32977610d179d188bcf137035a9e6">set_boundary_element()</a>, it precomputes the values and derivatives of the shape functions and the element transformation in the integration points. Then you can use the accessor functions to query these values.<p>
A <a class="el" href="classimaging_1_1FemKernel.html" title="Computes the values of the shape functions and the element transformation in the...">FemKernel</a> object is automatically created by <a class="el" href="classimaging_1_1Assembler.html#fd1570fa5cbd33b81e8435c01ac9f244">Assembler::assemble()</a>, <a class="el" href="classimaging_1_1Assembler.html#05276ecac49451b7f5a6d27db14d462e">Assembler::assemble_stiffness_matrix()</a> or <a class="el" href="classimaging_1_1Assembler.html#d7ae282c310e3805990efdd6a5f332b9">Assembler::assemble_force_vector()</a> and then iteratively set to the elements in a given grid during the assembly process. The initialized kernel is then passed to the equation object of the current FE computation. In the implementation of the equation (cf. <a class="el" href="classimaging_1_1EquationInterface.html" title="Abstract base class of all PDEs to be solved using the finite element module.">EquationInterface</a>) you can query the kernel to compute the equation coefficients which you then pass back to the assembly function.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classimaging_1_1EquationInterface.html" title="Abstract base class of all PDEs to be solved using the finite element module.">EquationInterface</a> </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="0784d605f938b3dfc99192465d76b6dc"></a><!-- doxytag: member="imaging::FemKernel::FemKernel" ref="0784d605f938b3dfc99192465d76b6dc" args="(const Grid&lt; fem_types &gt; &amp;grid)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classimaging_1_1FemKernel.html">imaging::FemKernel</a>&lt; fem_types &gt;::<a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classimaging_1_1Grid.html">Grid</a>&lt; fem_types &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>grid</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct kernel from <em>grid</em>. The kernel object stores only a reference to the grid. When the kernel is later on set to an element by calling void <a class="el" href="classimaging_1_1FemKernel.html#809e84d34ff6875978570d112210ead3">set_element(std::size_t element)</a> or <a class="el" href="classimaging_1_1FemKernel.html#8af32977610d179d188bcf137035a9e6">set_boundary_element(std::size_t element)</a> the argument <em>element</em> refers to <em>grid</em>. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="3a0ac5880414db3603a76a358e8d32bd"></a><!-- doxytag: member="imaging::FemKernel::grid" ref="3a0ac5880414db3603a76a358e8d32bd" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classimaging_1_1Grid.html">Grid</a>&lt;fem_types&gt;&amp; <a class="el" href="classimaging_1_1FemKernel.html">imaging::FemKernel</a>&lt; fem_types &gt;::grid           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a reference to the grid, which was passed to kernel during construction. The kernel object stores only a reference to the grid. 
<p>Referenced by <a class="el" href="TvFlowStep_8hpp-source.html#l00071">imaging::TvFlowStep&lt; fem_types &gt;::force_vector()</a>, <a class="el" href="PoissonEquation_8hpp-source.html#l00057">imaging::PoissonEquation&lt; fem_types &gt;::force_vector()</a>, <a class="el" href="McmStep_8hpp-source.html#l00077">imaging::McmStep&lt; fem_types &gt;::force_vector()</a>, <a class="el" href="GeodesicActiveContourStep_8hpp-source.html#l00115">imaging::GeodesicActiveContourStep&lt; fem_types &gt;::force_vector()</a>, <a class="el" href="DiffusionStep_8hpp-source.html#l00080">imaging::DiffusionStep&lt; fem_types &gt;::force_vector()</a>, <a class="el" href="PoissonEquation_8hpp-source.html#l00065">imaging::PoissonEquation&lt; fem_types &gt;::force_vector_at_boundary()</a>, <a class="el" href="TvFlowStep_8hpp-source.html#l00090">imaging::TvFlowStep&lt; fem_types &gt;::sanity_check_force_vector()</a>, <a class="el" href="PoissonEquation_8hpp-source.html#l00077">imaging::PoissonEquation&lt; fem_types &gt;::sanity_check_force_vector()</a>, <a class="el" href="McmStep_8hpp-source.html#l00102">imaging::McmStep&lt; fem_types &gt;::sanity_check_force_vector()</a>, <a class="el" href="GeodesicActiveContourStep_8hpp-source.html#l00145">imaging::GeodesicActiveContourStep&lt; fem_types &gt;::sanity_check_force_vector()</a>, <a class="el" href="DiffusionStep_8hpp-source.html#l00099">imaging::DiffusionStep&lt; fem_types &gt;::sanity_check_force_vector()</a>, <a class="el" href="TvFlowStep_8hpp-source.html#l00079">imaging::TvFlowStep&lt; fem_types &gt;::sanity_check_stiffness_matrix()</a>, <a class="el" href="McmStep_8hpp-source.html#l00091">imaging::McmStep&lt; fem_types &gt;::sanity_check_stiffness_matrix()</a>, <a class="el" href="GeodesicActiveContourStep_8hpp-source.html#l00131">imaging::GeodesicActiveContourStep&lt; fem_types &gt;::sanity_check_stiffness_matrix()</a>, <a class="el" href="DiffusionStep_8hpp-source.html#l00088">imaging::DiffusionStep&lt; fem_types &gt;::sanity_check_stiffness_matrix()</a>, <a class="el" href="TvFlowStep_8hpp-source.html#l00057">imaging::TvFlowStep&lt; fem_types &gt;::stiffness_matrix()</a>, <a class="el" href="McmStep_8hpp-source.html#l00062">imaging::McmStep&lt; fem_types &gt;::stiffness_matrix()</a>, <a class="el" href="GeodesicActiveContourStep_8hpp-source.html#l00095">imaging::GeodesicActiveContourStep&lt; fem_types &gt;::stiffness_matrix()</a>, and <a class="el" href="DiffusionStep_8hpp-source.html#l00067">imaging::DiffusionStep&lt; fem_types &gt;::stiffness_matrix()</a>.</p>

</div>
</div><p>
<a class="anchor" name="809e84d34ff6875978570d112210ead3"></a><!-- doxytag: member="imaging::FemKernel::set_element" ref="809e84d34ff6875978570d112210ead3" args="(std::size_t element)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classimaging_1_1FemKernel.html">imaging::FemKernel</a>&lt; fem_types &gt;::set_element           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>element</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes the kernel to <em>element</em>, computes<ul>
<li>the values and derivatives of the shape functions and</li><li>the element transform determinant (Jacobian of the transform), and stores them. This function is relatively expensive whereas the retrieval of the computed values later on is cheap. As long as <a class="el" href="classimaging_1_1FemKernel.html#809e84d34ff6875978570d112210ead3">set_element()</a> or <a class="el" href="classimaging_1_1FemKernel.html#19c6e5df6f1325cf605e71011afb20ac">lazy_set_element()</a> are not called with a different parameter <em>element</em>, <a class="el" href="classimaging_1_1FemKernel.html#8e37e706ffa692206e0c2153c7cb9de5">current_element()</a> will return <em>element</em>. </li></ul>

<p>References <a class="el" href="matrix__utilities_8cxx-source.html#l00019">imaging::inverse()</a>.</p>

<p>Referenced by <a class="el" href="Assembler_8hpp-source.html#l00072">imaging::Assembler::assemble()</a>, <a class="el" href="Assembler_8hpp-source.html#l00278">imaging::Assembler::assemble_force_vector()</a>, <a class="el" href="Assembler_8hpp-source.html#l00187">imaging::Assembler::assemble_stiffness_matrix()</a>, <a class="el" href="FeFunctionInterface_8hpp-source.html#l00181">imaging::average()</a>, <a class="el" href="FeFunctionInterface_8hpp-source.html#l00051">imaging::integrate()</a>, <a class="el" href="FeFunctionInterface_8hpp-source.html#l00095">imaging::maximum()</a>, and <a class="el" href="FeFunctionInterface_8hpp-source.html#l00137">imaging::minimum()</a>.</p>

</div>
</div><p>
<a class="anchor" name="8af32977610d179d188bcf137035a9e6"></a><!-- doxytag: member="imaging::FemKernel::set_boundary_element" ref="8af32977610d179d188bcf137035a9e6" args="(std::size_t boundary_element)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classimaging_1_1FemKernel.html">imaging::FemKernel</a>&lt; fem_types &gt;::set_boundary_element           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>boundary_element</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes the kernel to <em>boundary_element</em>, computes<ul>
<li>the values and derivatives of the boundary shape functions and</li><li>the boundary element transform determinant (determinant of the Jacobian of the transform), and stores them. This function is relatively expensive whereas the retrieval of the computed values later on is cheap. As long as <a class="el" href="classimaging_1_1FemKernel.html#8af32977610d179d188bcf137035a9e6">set_boundary_element()</a> is not called with a different parameter <em>element</em>, <a class="el" href="classimaging_1_1FemKernel.html#9b2e2924edb7cc5f3c00166308493f7e">current_boundary_element()</a> will return <em>boundary_element</em>. </li></ul>

<p>References <a class="el" href="FemKernel_8hpp-source.html#l00117">imaging::FemKernel&lt; fem_types &gt;::boundary_normal()</a>, and <a class="el" href="matrix__utilities_8cxx-source.html#l00019">imaging::inverse()</a>.</p>

<p>Referenced by <a class="el" href="Assembler_8hpp-source.html#l00072">imaging::Assembler::assemble()</a>, <a class="el" href="Assembler_8hpp-source.html#l00278">imaging::Assembler::assemble_force_vector()</a>, and <a class="el" href="Assembler_8hpp-source.html#l00187">imaging::Assembler::assemble_stiffness_matrix()</a>.</p>

</div>
</div><p>
<a class="anchor" name="19c6e5df6f1325cf605e71011afb20ac"></a><!-- doxytag: member="imaging::FemKernel::lazy_set_element" ref="19c6e5df6f1325cf605e71011afb20ac" args="(std::size_t element)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classimaging_1_1FemKernel.html">imaging::FemKernel</a>&lt; fem_types &gt;::lazy_set_element           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>element</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes the kernel to <em>element</em>, but does <em>not</em> compute new values of the shape and transformation functions. Use this function if you know for sure that the geometry of the new element is exactly the same as the one of the previous element. As long as <a class="el" href="classimaging_1_1FemKernel.html#809e84d34ff6875978570d112210ead3">set_element()</a> or <a class="el" href="classimaging_1_1FemKernel.html#19c6e5df6f1325cf605e71011afb20ac">lazy_set_element()</a> are not called with a different parameter <em>element</em>, <a class="el" href="classimaging_1_1FemKernel.html#8e37e706ffa692206e0c2153c7cb9de5">current_element()</a> will return <em>element</em>. 
<p>Referenced by <a class="el" href="Assembler_8hpp-source.html#l00072">imaging::Assembler::assemble()</a>, <a class="el" href="Assembler_8hpp-source.html#l00278">imaging::Assembler::assemble_force_vector()</a>, <a class="el" href="Assembler_8hpp-source.html#l00187">imaging::Assembler::assemble_stiffness_matrix()</a>, <a class="el" href="FeFunctionInterface_8hpp-source.html#l00181">imaging::average()</a>, <a class="el" href="FeFunctionInterface_8hpp-source.html#l00051">imaging::integrate()</a>, <a class="el" href="FeFunctionInterface_8hpp-source.html#l00095">imaging::maximum()</a>, and <a class="el" href="FeFunctionInterface_8hpp-source.html#l00137">imaging::minimum()</a>.</p>

</div>
</div><p>
<a class="anchor" name="e1f68b1ef8f507c591ef0f4bdba42806"></a><!-- doxytag: member="imaging::FemKernel::shape_value" ref="e1f68b1ef8f507c591ef0f4bdba42806" args="(std::size_t integrator_node, std::size_t element_node) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> <a class="el" href="classimaging_1_1FemKernel.html">imaging::FemKernel</a>&lt; fem_types &gt;::shape_value           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>integrator_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>element_node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the value of the shape function assciated with <em>element_node</em> in the integration node <em>integrator_node</em>. 
<p>Referenced by <a class="el" href="SimpleEquationAdaptor_8hpp-source.html#l00084">imaging::SimpleEquationAdaptor&lt; equation_t &gt;::force_vector()</a>, <a class="el" href="Grid_8hpp-source.html#l00232">imaging::Grid&lt; fem_types &gt;::interpolate_value()</a>, and <a class="el" href="SimpleEquationAdaptor_8hpp-source.html#l00046">imaging::SimpleEquationAdaptor&lt; equation_t &gt;::stiffness_matrix()</a>.</p>

</div>
</div><p>
<a class="anchor" name="8c0eedb686a8ed23245fe4fd47f697a7"></a><!-- doxytag: member="imaging::FemKernel::shape_gradient" ref="8c0eedb686a8ed23245fe4fd47f697a7" args="(std::size_t integrator_node, std::size_t element_node) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">ublas::fixed_vector</a>&lt;<a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>, fem_types::data_dimension&gt;&amp; <a class="el" href="classimaging_1_1FemKernel.html">imaging::FemKernel</a>&lt; fem_types &gt;::shape_gradient           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>integrator_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>element_node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the gradient of the shape function assciated with <em>element_node</em> in the integration node <em>integrator_node</em>. 
<p>Referenced by <a class="el" href="SimpleEquationAdaptor_8hpp-source.html#l00084">imaging::SimpleEquationAdaptor&lt; equation_t &gt;::force_vector()</a>, <a class="el" href="Grid_8hpp-source.html#l00256">imaging::Grid&lt; fem_types &gt;::interpolate_gradient()</a>, and <a class="el" href="SimpleEquationAdaptor_8hpp-source.html#l00046">imaging::SimpleEquationAdaptor&lt; equation_t &gt;::stiffness_matrix()</a>.</p>

</div>
</div><p>
<a class="anchor" name="35d900808ae8e7441a93aaf7335b92a4"></a><!-- doxytag: member="imaging::FemKernel::transform_determinant" ref="35d900808ae8e7441a93aaf7335b92a4" args="(std::size_t integrator_node) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> <a class="el" href="classimaging_1_1FemKernel.html">imaging::FemKernel</a>&lt; fem_types &gt;::transform_determinant           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>integrator_node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the value of the transformation determinant (determinant of the Jacobian of the transform) in the integration node <em>integrator_node</em>. This value reflects the distortion of the actual element with respect to its reference element. Note that <em>integrator_node</em> refers to the corresponding node of the <em>boundary</em> integrator. 
<p>Referenced by <a class="el" href="Assembler_8hpp-source.html#l00072">imaging::Assembler::assemble()</a>, <a class="el" href="Assembler_8hpp-source.html#l00278">imaging::Assembler::assemble_force_vector()</a>, <a class="el" href="Assembler_8hpp-source.html#l00187">imaging::Assembler::assemble_stiffness_matrix()</a>, <a class="el" href="FeFunctionInterface_8hpp-source.html#l00181">imaging::average()</a>, and <a class="el" href="FeFunctionInterface_8hpp-source.html#l00051">imaging::integrate()</a>.</p>

</div>
</div><p>
<a class="anchor" name="f3d0c86ea00cff4de63e390b5f3f4700"></a><!-- doxytag: member="imaging::FemKernel::shape_boundary_value" ref="f3d0c86ea00cff4de63e390b5f3f4700" args="(std::size_t integrator_node, std::size_t element_node) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> <a class="el" href="classimaging_1_1FemKernel.html">imaging::FemKernel</a>&lt; fem_types &gt;::shape_boundary_value           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>integrator_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>element_node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the value of shape function associated with <em>element_node</em> on the parent element of the current boundary element in the integration node <em>integrator_node</em> on the boundary element. This means that the shape function <em>on the element</em> is evaluated <em>at the boundary</em> of the element. Keep in mind that here the element is <em>not</em> the current element but the parent element of the current boundary element. I.e. this function depends only on the current boundary element. Note that <em>integrator_node</em> refers to the corresponding node of the <em>boundary</em> integrator. 
<p>Referenced by <a class="el" href="SimpleEquationAdaptor_8hpp-source.html#l00145">imaging::SimpleEquationAdaptor&lt; equation_t &gt;::force_vector_at_boundary()</a>, <a class="el" href="Grid_8hpp-source.html#l00282">imaging::Grid&lt; fem_types &gt;::interpolate_boundary_value()</a>, and <a class="el" href="SimpleEquationAdaptor_8hpp-source.html#l00112">imaging::SimpleEquationAdaptor&lt; equation_t &gt;::stiffness_matrix_at_boundary()</a>.</p>

</div>
</div><p>
<a class="anchor" name="3ad8cd514cf6f0ab06448e1e289666e3"></a><!-- doxytag: member="imaging::FemKernel::shape_boundary_derivative" ref="3ad8cd514cf6f0ab06448e1e289666e3" args="(std::size_t integrator_node, std::size_t element_node) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> <a class="el" href="classimaging_1_1FemKernel.html">imaging::FemKernel</a>&lt; fem_types &gt;::shape_boundary_derivative           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>integrator_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>element_node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the gradient of shape function associated with <em>element_node</em> on the parent element of the current boundary element in the integration node <em>integrator_node</em> on the boundary element. This means that the gradient of the shape function <em>on the element</em> is evaluated <em>at the boundary</em> of the element. Keep in mind that here the element is <em>not</em> the current element but the parent element of the current boundary element. I.e. this function depends only on the current boundary element. Note that <em>integrator_node</em> refers to the corresponding node of the <em>boundary</em> integrator. 
<p>Referenced by <a class="el" href="Grid_8hpp-source.html#l00308">imaging::Grid&lt; fem_types &gt;::interpolate_boundary_derivative()</a>, and <a class="el" href="SimpleEquationAdaptor_8hpp-source.html#l00112">imaging::SimpleEquationAdaptor&lt; equation_t &gt;::stiffness_matrix_at_boundary()</a>.</p>

</div>
</div><p>
<a class="anchor" name="8087e3cb00a824dfc2614d13175ef800"></a><!-- doxytag: member="imaging::FemKernel::boundary_transform_determinant" ref="8087e3cb00a824dfc2614d13175ef800" args="(std::size_t integrator_node) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> <a class="el" href="classimaging_1_1FemKernel.html">imaging::FemKernel</a>&lt; fem_types &gt;::boundary_transform_determinant           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>integrator_node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the value of the transformation determinant (determinant of the Jacobian of the transform) of the transformation which transforms the current boundary element to the reference element. This value reflects the distortion of the actual boundary element with respect to its reference element. 
<p>Referenced by <a class="el" href="Assembler_8hpp-source.html#l00072">imaging::Assembler::assemble()</a>, <a class="el" href="Assembler_8hpp-source.html#l00278">imaging::Assembler::assemble_force_vector()</a>, <a class="el" href="Assembler_8hpp-source.html#l00187">imaging::Assembler::assemble_stiffness_matrix()</a>, and <a class="el" href="SimpleEquationAdaptor_8hpp-source.html#l00112">imaging::SimpleEquationAdaptor&lt; equation_t &gt;::stiffness_matrix_at_boundary()</a>.</p>

</div>
</div><p>
<a class="anchor" name="a6227854349e3feb74871eae3fce5593"></a><!-- doxytag: member="imaging::FemKernel::boundary_normal" ref="a6227854349e3feb74871eae3fce5593" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">ublas::fixed_vector</a>&lt;<a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>, fem_types::data_dimension&gt;&amp; <a class="el" href="classimaging_1_1FemKernel.html">imaging::FemKernel</a>&lt; fem_types &gt;::boundary_normal           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the boundary normal in the integration node <em>integrator_node</em> of the current boundary element. Note that <em>integrator_node</em> refers to the corresponding node of the <em>boundary</em> integrator. 
<p>Referenced by <a class="el" href="FemKernel_8hpp-source.html#l00168">imaging::FemKernel&lt; fem_types &gt;::set_boundary_element()</a>.</p>

</div>
</div><p>
<a class="anchor" name="8e37e706ffa692206e0c2153c7cb9de5"></a><!-- doxytag: member="imaging::FemKernel::current_element" ref="8e37e706ffa692206e0c2153c7cb9de5" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classimaging_1_1FemKernel.html">imaging::FemKernel</a>&lt; fem_types &gt;::current_element           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the index of the current element. In most situations you should assume that the kernel is initialized to this element. 
<p>Referenced by <a class="el" href="Grid_8hpp-source.html#l00332">imaging::Grid&lt; fem_types &gt;::global_coordinates()</a>, <a class="el" href="Grid_8hpp-source.html#l00256">imaging::Grid&lt; fem_types &gt;::interpolate_gradient()</a>, and <a class="el" href="Grid_8hpp-source.html#l00232">imaging::Grid&lt; fem_types &gt;::interpolate_value()</a>.</p>

</div>
</div><p>
<a class="anchor" name="9b2e2924edb7cc5f3c00166308493f7e"></a><!-- doxytag: member="imaging::FemKernel::current_boundary_element" ref="9b2e2924edb7cc5f3c00166308493f7e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classimaging_1_1FemKernel.html">imaging::FemKernel</a>&lt; fem_types &gt;::current_boundary_element           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the index of the current boundary element. In most situations you should assume that the kernel is initialized to this boundary element. 
<p>Referenced by <a class="el" href="Grid_8hpp-source.html#l00308">imaging::Grid&lt; fem_types &gt;::interpolate_boundary_derivative()</a>, and <a class="el" href="Grid_8hpp-source.html#l00282">imaging::Grid&lt; fem_types &gt;::interpolate_boundary_value()</a>.</p>

</div>
</div><p>
<a class="anchor" name="51eed7c8f1585b7dabbb04e3fc1cce05"></a><!-- doxytag: member="imaging::FemKernel::is_boundary_node" ref="51eed7c8f1585b7dabbb04e3fc1cce05" args="(std::size_t element_node) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classimaging_1_1FemKernel.html">imaging::FemKernel</a>&lt; fem_types &gt;::is_boundary_node           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>element_node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <em>true</em> if <em>element_node</em> refers to a node index on the reference element which lies at the boundary of the grid in the current element. 
<p>Referenced by <a class="el" href="SimpleEquationAdaptor_8hpp-source.html#l00084">imaging::SimpleEquationAdaptor&lt; equation_t &gt;::force_vector()</a>, and <a class="el" href="SimpleEquationAdaptor_8hpp-source.html#l00046">imaging::SimpleEquationAdaptor&lt; equation_t &gt;::stiffness_matrix()</a>.</p>

</div>
</div><p>
<a class="anchor" name="1b04fbafeabbc6d3d8a8b45d169473f8"></a><!-- doxytag: member="imaging::FemKernel::boundary_normal_at_node" ref="1b04fbafeabbc6d3d8a8b45d169473f8" args="(std::size_t element_node) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">ublas::fixed_vector</a>&lt;<a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>, fem_types::data_dimension&gt; <a class="el" href="classimaging_1_1FemKernel.html">imaging::FemKernel</a>&lt; fem_types &gt;::boundary_normal_at_node           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>element_node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the boundary normal in <em>element_node</em> of the current element. The parameter <em>element_node</em> refers to the index of the node as in the reference element. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>imaging2/fem/<a class="el" href="FemKernel_8hpp-source.html">FemKernel.hpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Feb 10 10:01:31 2009 for imaging2 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
