<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>imaging2: imaging::Grid&lt; fem_types &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceimaging.html">imaging</a>::<a class="el" href="classimaging_1_1Grid.html">Grid</a>
  </div>
</div>
<div class="contents">
<h1>imaging::Grid&lt; fem_types &gt; Class Template Reference<br>
<small>
[<a class="el" href="group__fem.html">Finite Element Module</a>]</small>
</h1><!-- doxytag: class="imaging::Grid" -->Provides the data structure and accessor functions for a FE grid.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="Grid_8hpp-source.html">Grid.hpp</a>&gt;</code>
<p>

<p>
<a href="classimaging_1_1Grid-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3389b47fad07ce288a01d8415ecf2ebf"></a><!-- doxytag: member="imaging::Grid::vertex_t" ref="3389b47fad07ce288a01d8415ecf2ebf" args="" -->
typedef <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">ublas::fixed_vector</a><br>
&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>, <br>
fem_types::data_dimension &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#3389b47fad07ce288a01d8415ecf2ebf">vertex_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The data type of the element coordinates (determined by the template parameter <em>fem_types</em>). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="340246aba7d3d724f9e4f0cc07a72a41"></a><!-- doxytag: member="imaging::Grid::transform_t" ref="340246aba7d3d724f9e4f0cc07a72a41" args="" -->
typedef fem_types::transform_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#340246aba7d3d724f9e4f0cc07a72a41">transform_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The element transformation class (determined by the template parameter <em>fem_types</em>). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="198dec36459beb0c6edd828bff8b139f"></a><!-- doxytag: member="imaging::Grid::shape_function_t" ref="198dec36459beb0c6edd828bff8b139f" args="" -->
typedef fem_types::shape_function_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#198dec36459beb0c6edd828bff8b139f">shape_function_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The shape function class (determined by the template parameter <em>fem_types</em>). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9ad7e0a5db4feb9d595726643a1595b2"></a><!-- doxytag: member="imaging::Grid::integrator_t" ref="9ad7e0a5db4feb9d595726643a1595b2" args="" -->
typedef fem_types::integrator_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#9ad7e0a5db4feb9d595726643a1595b2">integrator_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The integrator class (determined by the template parameter <em>fem_types</em>). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bc1be14be885f42ff4feb47bcd7ddcd7"></a><!-- doxytag: member="imaging::Grid::boundary_integrator_t" ref="bc1be14be885f42ff4feb47bcd7ddcd7" args="" -->
typedef <br>
fem_types::boundary_integrator_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#bc1be14be885f42ff4feb47bcd7ddcd7">boundary_integrator_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The boundary integrator class (determined by the template parameter <em>fem_types</em>). <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#14d802bb6ffb6ad380f3bc1bdd416c4d">Grid</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#6e399fd8923dcfffb21c61c9ea689d08">n_elements</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#01dc5b8987d45ff63f25957cc0a7f599">n_vertices</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#db1f6524c9d947a9014f114ae1dc2a3e">n_nodes</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#211e3691a56d8c48745f622dbe488dff">n_boundary_nodes</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#5dad80f517de6a74a639e22dface1827">n_boundary_elements</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#de28b4bda070795a71e591204970e79b">set_vertex</a> (<a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> global_vertex_index, const <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">vertex_t</a> &amp;vertex)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">vertex_t</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#924d9f0ef1144a6610784d0d7d707763">vertex</a> (<a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> global_vertex_index) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#e064617e7467ec2df16d210f8c5b0654">set_vertex</a> (<a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> element_index, <a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> vertex_index, const <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">vertex_t</a> &amp;vertex)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">vertex_t</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#35abff7709c5b65e78e15c793e66c5ec">vertex</a> (<a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> element_index, <a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> vertex_index) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#474d93043bc61854521447eb4058b978">global_vertex_index</a> (<a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> element_index, <a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> vertex_index) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#8a13a0d51c912ef4da14abb874af7ba6">set_global_vertex_index</a> (<a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> element_index, <a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> vertex_index, <a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> global_vertex_index)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#1680fe274a6325495b00aa1e24f7c7cf">global_node_index</a> (<a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> element_index, <a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> node_index) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#00eb122a21ed5acd992dde2bb598259d">set_global_node_index</a> (<a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> element_index, <a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> node_index, <a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> global_node_index)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#703df0fd19ba64f6cc50cce221463ee0">set_boundary_element</a> (<a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> boundary_element_index, <a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> parent_element_index, <a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> parent_element_face)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#de5ce3f534438b08369fc8cc34bef10f">parent_element</a> (<a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> boundary_element_index) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#5a8de87cdd9da39e0509bc9412ddaf6f">parent_element_face</a> (<a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> boundary_element_index) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#d7edf49be6e31971abed70f970e6292b">is_boundary_node</a> (<a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> global_node_index) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#88fcf85d1465b81ef33bee71205ce915">is_boundary_node</a> (<a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> element_index, <a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> node_index) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">vertex_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#9559cdc4969719992a7965a6189beb01">boundary_normal</a> (<a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> global_node_index) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">vertex_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#65fcee35955b7e3fa29d7648d5698841">boundary_normal</a> (<a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> element_index, <a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> node_index) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#d0d54600dc8c664e1b09df0b68f4a205">set_regular</a> (bool is_regular)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#2d84a94ce111449ac736ec49abf02b11">is_regular</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#8103c8b3047f28d7c4907d0b33a30db4">set_dimensions</a> (<a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> n_vertices, <a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> n_elements, <a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> n_boundary_elements, <a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> n_nodes)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#2649307cce81bde332c507d33deaa557">element_transform</a> (<a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> element_index, <a class="el" href="classimaging_1_1Grid.html#340246aba7d3d724f9e4f0cc07a72a41">transform_t</a> &amp;transform) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#27413c9e0eec188e35203506921f9078">interpolate_value</a> (<a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> integrator_node, const ublas::vector&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &gt; &amp;data, const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; fem_types &gt; &amp;kernel, <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &amp;value) const </td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#7c1d3bcebbd329a809a10833aa585dea">interpolate_value</a> (<a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> integrator_node, const ublas::vector&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &gt; &amp;data, const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; fem_types &gt; &amp;kernel, <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">ublas::fixed_vector</a>&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>, N &gt; &amp;value) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#97763c7c85baf8e239db7d589152f058">interpolate_gradient</a> (<a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> integrator_node, const ublas::vector&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &gt; &amp;data, const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; fem_types &gt; &amp;kernel, <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">ublas::fixed_vector</a>&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>, <a class="el" href="classimaging_1_1Grid.html#e4cd83c5d52896a4b27627575ecb9163">data_dimension</a> &gt; &amp;gradient) const </td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#1ef3411ee338c8700107155fabf1fc46">interpolate_gradient</a> (<a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> integrator_node, const ublas::vector&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &gt; &amp;data, const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; fem_types &gt; &amp;kernel, <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__matrix.html">ublas::fixed_matrix</a>&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>, <a class="el" href="classimaging_1_1Grid.html#e4cd83c5d52896a4b27627575ecb9163">data_dimension</a>, N &gt; &amp;gradient) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#33a73189dc4bb4f69211cdfdb247add3">interpolate_boundary_value</a> (<a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> boundary_integrator_node, const ublas::mapped_vector&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &gt; &amp;data, const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; fem_types &gt; &amp;kernel, <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &amp;value) const </td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#7d0ad6eaa9bff5c8a9235b8467231cb4">interpolate_boundary_value</a> (<a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> boundary_integrator_node, const ublas::mapped_vector&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &gt; &amp;data, const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; fem_types &gt; &amp;kernel, <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">ublas::fixed_vector</a>&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>, N &gt; &amp;value) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#639d16fceee54638ef934d420a38d2d6">interpolate_boundary_derivative</a> (<a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> boundary_integrator_node, const ublas::mapped_vector&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &gt; &amp;data, const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; fem_types &gt; &amp;kernel, <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &amp;value) const </td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#447628fa4232daa9e7c137ef2813b1cb">interpolate_boundary_derivative</a> (<a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> boundary_integrator_node, const ublas::mapped_vector&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &gt; &amp;data, const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; fem_types &gt; &amp;kernel, <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">ublas::fixed_vector</a>&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>, N &gt; &amp;value) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#40b55488ea9b6b8aab64dce21e383d22">global_coordinates</a> (<a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> integrator_node, const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; fem_types &gt; &amp;kernel, <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">ublas::fixed_vector</a>&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>, <a class="el" href="classimaging_1_1Grid.html#e4cd83c5d52896a4b27627575ecb9163">data_dimension</a> &gt; &amp;coordinates) const </td></tr>

<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e4cd83c5d52896a4b27627575ecb9163"></a><!-- doxytag: member="imaging::Grid::data_dimension" ref="e4cd83c5d52896a4b27627575ecb9163" args="" -->
static const <a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#e4cd83c5d52896a4b27627575ecb9163">data_dimension</a> = fem_types::data_dimension</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of coordinates of the element vertices (determined by the template parameter <em>fem_types</em>). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b610ba231f02ba6fc07e761778254aa4"></a><!-- doxytag: member="imaging::Grid::n_element_vertices" ref="b610ba231f02ba6fc07e761778254aa4" args="" -->
static const <a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#b610ba231f02ba6fc07e761778254aa4">n_element_vertices</a> = fem_types::transform_t::n_element_vertices</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of vertices per element (determined by the template parameter <em>fem_types</em>). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="03d468301370cbf9cab31ab64f9374f6"></a><!-- doxytag: member="imaging::Grid::n_element_nodes" ref="03d468301370cbf9cab31ab64f9374f6" args="" -->
static const <a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#03d468301370cbf9cab31ab64f9374f6">n_element_nodes</a> = fem_types::shape_function_t::n_element_nodes</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of nodes per element (determined by the template parameter <em>fem_types</em>). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="905e296985ba8bc86ab8a5d5dd807cda"></a><!-- doxytag: member="imaging::Grid::n_element_faces" ref="905e296985ba8bc86ab8a5d5dd807cda" args="" -->
static const <a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Grid.html#905e296985ba8bc86ab8a5d5dd807cda">n_element_faces</a> = fem_types::transform_t::n_element_faces</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of nodes per element (determined by the template parameter <em>fem_types</em>). <br></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>BoundaryElement</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class fem_types&gt;<br>
 class imaging::Grid&lt; fem_types &gt;</h3>

Provides the data structure and accessor functions for a FE grid. 
<p>
<a class="el" href="classimaging_1_1Grid.html" title="Provides the data structure and accessor functions for a FE grid.">Grid</a> stores all the data to access the elements of a FE grid and obtain their geometry. In addition it keeps track of the boundary of the grid and elements there.<p>
In the following we give a more detailed description of how <a class="el" href="classimaging_1_1Grid.html" title="Provides the data structure and accessor functions for a FE grid.">Grid</a> stores this information. The basic building block of a grid is an element. We assume an element to have vertices, faces and nodes. Each of these has a unique index (running from zero to <a class="el" href="classimaging_1_1Grid.html#b610ba231f02ba6fc07e761778254aa4" title="The number of vertices per element (determined by the template parameter fem_types)...">Grid::n_element_vertices</a>, from zero to <a class="el" href="classimaging_1_1Grid.html#905e296985ba8bc86ab8a5d5dd807cda" title="The number of nodes per element (determined by the template parameter fem_types)...">Grid::n_element_faces</a> and from zero to <a class="el" href="classimaging_1_1Grid.html#03d468301370cbf9cab31ab64f9374f6" title="The number of nodes per element (determined by the template parameter fem_types)...">Grid::n_element_nodes</a>) on the reference element which carries over to the transformed elements in the grid.<p>
An element in the grid is identified by its element index which runs from zero to <a class="el" href="classimaging_1_1Grid.html#6e399fd8923dcfffb21c61c9ea689d08">n_elements()</a>. Every element has <a class="el" href="classimaging_1_1Grid.html#b610ba231f02ba6fc07e761778254aa4" title="The number of vertices per element (determined by the template parameter fem_types)...">Grid::n_element_vertices</a> vertices which are identified by their vertex indices. Each of the vertex indices is mapped to a global vertex index which refers to its position in a list of vertex coordinates.In other words, a combination of an <em>element index + vertex index</em> can be mapped to the <em>global vertex index</em> which again identifies the position of the element vertex coordinates in the vertex coordinate list. The vertex coordinates determine the position and the geometry of the element. In a grid consisting of triangular elements an element will always have three vertices. Elements in a quadrilateral or tetrahedral grid are defined by 4 vertices respectively. This also means that the number of vertices per element and the dimension of the vertex coordinates (which are determined by <a class="el" href="classimaging_1_1Grid.html#b610ba231f02ba6fc07e761778254aa4" title="The number of vertices per element (determined by the template parameter fem_types)...">Grid::n_element_vertices</a> and <a class="el" href="classimaging_1_1Grid.html#e4cd83c5d52896a4b27627575ecb9163" title="The number of coordinates of the element vertices (determined by the template parameter...">Grid::data_dimension</a>) always have to correspond to the element transformation (<a class="el" href="classimaging_1_1Grid.html#340246aba7d3d724f9e4f0cc07a72a41" title="The element transformation class (determined by the template parameter fem_types)...">Grid::transform_t</a>).<p>
The <em>element nodes</em>, in contrast, are defined by the shape function on the element. Again each node of a element is determined by its <em>node index</em> and is further mapped to a <em>global node index</em>. The coordinates of the nodes do not have to stored because the are completely determined by the coordinates of the vertices of their element. Instead, the global node indices refer to the position of the node in the stiffness matrix and the force vector of the FE problem. For linear shape functions on triangle elements or bilinear shape functions on quadrilateral elements the number of nodes per element is the same as the number of vertices and their actual positions coincide. For higher order shape functions there maybe more nodes than vertices. Clearly, the number of nodes per element (determined by <a class="el" href="classimaging_1_1Grid.html#03d468301370cbf9cab31ab64f9374f6" title="The number of nodes per element (determined by the template parameter fem_types)...">Grid::n_element_nodes</a>) has to match the type of shape functions (<a class="el" href="classimaging_1_1Grid.html#198dec36459beb0c6edd828bff8b139f" title="The shape function class (determined by the template parameter fem_types).">Grid::shape_function_t</a>).<p>
Finally, <a class="el" href="classimaging_1_1Grid.html" title="Provides the data structure and accessor functions for a FE grid.">Grid</a> keeps track of the boundary of the FE domain. The term <em>boundary element</em> refers to a face of an element (the <em>parent element</em>) which lies a the boundary of the grid. It is identified by its element index which runs from zero to <a class="el" href="classimaging_1_1Grid.html#5dad80f517de6a74a639e22dface1827">n_boundary_elements()</a>. For each boundary element the index of its parent element and the index of the corresponding face on the boundary element is stored. A <em>boundary vertex</em> is an element vertex which happens to on a boundary element. The same holds for a <em>boundary node</em>. For each boundary node the outer unit normal at the grid boundary is stored. This information has to be provided during the construction of the grid. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="14d802bb6ffb6ad380f3bc1bdd416c4d"></a><!-- doxytag: member="imaging::Grid::Grid" ref="14d802bb6ffb6ad380f3bc1bdd416c4d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::<a class="el" href="classimaging_1_1Grid.html">Grid</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default constructor. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="6e399fd8923dcfffb21c61c9ea689d08"></a><!-- doxytag: member="imaging::Grid::n_elements" ref="6e399fd8923dcfffb21c61c9ea689d08" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::n_elements           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of elements of the grid (excluding boundary elements). 
<p>Referenced by <a class="el" href="Assembler_8hpp-source.html#l00072">imaging::Assembler::assemble()</a>, <a class="el" href="Assembler_8hpp-source.html#l00278">imaging::Assembler::assemble_force_vector()</a>, <a class="el" href="Assembler_8hpp-source.html#l00187">imaging::Assembler::assemble_stiffness_matrix()</a>, <a class="el" href="FeFunctionInterface_8hpp-source.html#l00181">imaging::average()</a>, <a class="el" href="FeFunctionInterface_8hpp-source.html#l00051">imaging::integrate()</a>, <a class="el" href="FeFunctionInterface_8hpp-source.html#l00095">imaging::maximum()</a>, <a class="el" href="FeFunctionInterface_8hpp-source.html#l00137">imaging::minimum()</a>, and <a class="el" href="fem_2utilities_8cxx-source.html#l00162">imaging::triangulate_shape()</a>.</p>

</div>
</div><p>
<a class="anchor" name="01dc5b8987d45ff63f25957cc0a7f599"></a><!-- doxytag: member="imaging::Grid::n_vertices" ref="01dc5b8987d45ff63f25957cc0a7f599" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::n_vertices           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of element vertices of the grid. In case there is exactly shape function one per element vertex this equals the number of nodes. 
<p>Referenced by <a class="el" href="fem_2utilities_8cxx-source.html#l00162">imaging::triangulate_shape()</a>.</p>

</div>
</div><p>
<a class="anchor" name="db1f6524c9d947a9014f114ae1dc2a3e"></a><!-- doxytag: member="imaging::Grid::n_nodes" ref="db1f6524c9d947a9014f114ae1dc2a3e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::n_nodes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of element nodes of this grid. The number of element nodes equals the number of degrees of freedom of FE discretization of a scalar PDE on this grid. For a system of equations this number has to be multiplied by the number of equations to obtain the total number of degrees of freedom. 
<p>Referenced by <a class="el" href="Assembler_8hpp-source.html#l00072">imaging::Assembler::assemble()</a>, <a class="el" href="Assembler_8hpp-source.html#l00278">imaging::Assembler::assemble_force_vector()</a>, and <a class="el" href="Assembler_8hpp-source.html#l00187">imaging::Assembler::assemble_stiffness_matrix()</a>.</p>

</div>
</div><p>
<a class="anchor" name="211e3691a56d8c48745f622dbe488dff"></a><!-- doxytag: member="imaging::Grid::n_boundary_nodes" ref="211e3691a56d8c48745f622dbe488dff" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::n_boundary_nodes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of nodes which are at the boundary of the grid. The equations for these nodes will be influenced by boundary conditions. 
</div>
</div><p>
<a class="anchor" name="5dad80f517de6a74a639e22dface1827"></a><!-- doxytag: member="imaging::Grid::n_boundary_elements" ref="5dad80f517de6a74a639e22dface1827" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::n_boundary_elements           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of boundary elements, i.e. those boundary elements of parent elements which are at the actual boundary of the grid. 
<p>Referenced by <a class="el" href="Assembler_8hpp-source.html#l00072">imaging::Assembler::assemble()</a>, <a class="el" href="Assembler_8hpp-source.html#l00278">imaging::Assembler::assemble_force_vector()</a>, and <a class="el" href="Assembler_8hpp-source.html#l00187">imaging::Assembler::assemble_stiffness_matrix()</a>.</p>

</div>
</div><p>
<a class="anchor" name="de28b4bda070795a71e591204970e79b"></a><!-- doxytag: member="imaging::Grid::set_vertex" ref="de28b4bda070795a71e591204970e79b" args="(size_t global_vertex_index, const vertex_t &amp;vertex)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::set_vertex           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>global_vertex_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">vertex_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vertex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the vertex with global index <em>global_vertex_index</em> to <em>vertex</em>. 
<p>Referenced by <a class="el" href="fem_2utilities_8cxx-source.html#l00072">imaging::ellipse_grid()</a>, <a class="el" href="fem_2utilities_8cxx-source.html#l00162">imaging::triangulate_shape()</a>, and <a class="el" href="fem_2utilities_8cxx-source.html#l00023">imaging::uniform_grid()</a>.</p>

</div>
</div><p>
<a class="anchor" name="924d9f0ef1144a6610784d0d7d707763"></a><!-- doxytag: member="imaging::Grid::vertex" ref="924d9f0ef1144a6610784d0d7d707763" args="(size_t global_vertex_index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">vertex_t</a>&amp; <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::vertex           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>global_vertex_index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a const reference to the vertex with global index <em>global_vertex_index</em>. 
</div>
</div><p>
<a class="anchor" name="e064617e7467ec2df16d210f8c5b0654"></a><!-- doxytag: member="imaging::Grid::set_vertex" ref="e064617e7467ec2df16d210f8c5b0654" args="(size_t element_index, size_t vertex_index, const vertex_t &amp;vertex)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::set_vertex           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>element_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>vertex_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">vertex_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vertex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the vertex with index <em>vertex_index</em> on the element <em>element_index</em> to <em>vertex</em>. 
<p>References <a class="el" href="Grid_8hpp-source.html#l00133">imaging::Grid&lt; fem_types &gt;::global_vertex_index()</a>.</p>

</div>
</div><p>
<a class="anchor" name="35abff7709c5b65e78e15c793e66c5ec"></a><!-- doxytag: member="imaging::Grid::vertex" ref="35abff7709c5b65e78e15c793e66c5ec" args="(size_t element_index, size_t vertex_index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">vertex_t</a>&amp; <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::vertex           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>element_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>vertex_index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a const reference to the vertex with index <em>vertex_index</em> on the element <em>element_index</em>. 
<p>References <a class="el" href="Grid_8hpp-source.html#l00133">imaging::Grid&lt; fem_types &gt;::global_vertex_index()</a>.</p>

</div>
</div><p>
<a class="anchor" name="474d93043bc61854521447eb4058b978"></a><!-- doxytag: member="imaging::Grid::global_vertex_index" ref="474d93043bc61854521447eb4058b978" args="(size_t element_index, size_t vertex_index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::global_vertex_index           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>element_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>vertex_index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the global vertex index of the node with index <em>vertex_index</em> on the element <em>element_index</em>. This index corresponds to the index of the vertex coordinates in the vertex coordinate list stored by the <a class="el" href="classimaging_1_1Grid.html" title="Provides the data structure and accessor functions for a FE grid.">Grid</a> object. 
<p>Referenced by <a class="el" href="Grid_8hpp-source.html#l00223">imaging::Grid&lt; fem_types &gt;::element_transform()</a>, <a class="el" href="Grid_8hpp-source.html#l00127">imaging::Grid&lt; fem_types &gt;::set_vertex()</a>, and <a class="el" href="Grid_8hpp-source.html#l00130">imaging::Grid&lt; fem_types &gt;::vertex()</a>.</p>

</div>
</div><p>
<a class="anchor" name="8a13a0d51c912ef4da14abb874af7ba6"></a><!-- doxytag: member="imaging::Grid::set_global_vertex_index" ref="8a13a0d51c912ef4da14abb874af7ba6" args="(size_t element_index, size_t vertex_index, size_t global_vertex_index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::set_global_vertex_index           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>element_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>vertex_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>global_vertex_index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the global vertex index of the vertex with index <em>vertex_index</em> on the element <em>element_index</em>. This index corresponds to the index of the vertex coordinates in the vertex coordinate list stored by the <a class="el" href="classimaging_1_1Grid.html" title="Provides the data structure and accessor functions for a FE grid.">Grid</a> object. 
<p>Referenced by <a class="el" href="fem_2utilities_8cxx-source.html#l00072">imaging::ellipse_grid()</a>, <a class="el" href="fem_2utilities_8cxx-source.html#l00162">imaging::triangulate_shape()</a>, and <a class="el" href="fem_2utilities_8cxx-source.html#l00023">imaging::uniform_grid()</a>.</p>

</div>
</div><p>
<a class="anchor" name="1680fe274a6325495b00aa1e24f7c7cf"></a><!-- doxytag: member="imaging::Grid::global_node_index" ref="1680fe274a6325495b00aa1e24f7c7cf" args="(size_t element_index, size_t node_index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::global_node_index           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>element_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>node_index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the global node index of the node with index <em>node_index</em> on the element <em>element_index</em>. This index corresponds to the position of the node in the stiffness matrix and the force vector of the associated FE problem. 
<p>Referenced by <a class="el" href="Assembler_8hpp-source.html#l00072">imaging::Assembler::assemble()</a>, <a class="el" href="Assembler_8hpp-source.html#l00278">imaging::Assembler::assemble_force_vector()</a>, <a class="el" href="Assembler_8hpp-source.html#l00187">imaging::Assembler::assemble_stiffness_matrix()</a>, <a class="el" href="Grid_8hpp-source.html#l00200">imaging::Grid&lt; fem_types &gt;::boundary_normal()</a>, <a class="el" href="Grid_8hpp-source.html#l00308">imaging::Grid&lt; fem_types &gt;::interpolate_boundary_derivative()</a>, <a class="el" href="Grid_8hpp-source.html#l00282">imaging::Grid&lt; fem_types &gt;::interpolate_boundary_value()</a>, <a class="el" href="Grid_8hpp-source.html#l00256">imaging::Grid&lt; fem_types &gt;::interpolate_gradient()</a>, <a class="el" href="Grid_8hpp-source.html#l00232">imaging::Grid&lt; fem_types &gt;::interpolate_value()</a>, <a class="el" href="Grid_8hpp-source.html#l00177">imaging::Grid&lt; fem_types &gt;::is_boundary_node()</a>, and <a class="el" href="Grid_8hpp-source.html#l00145">imaging::Grid&lt; fem_types &gt;::set_boundary_element()</a>.</p>

</div>
</div><p>
<a class="anchor" name="00eb122a21ed5acd992dde2bb598259d"></a><!-- doxytag: member="imaging::Grid::set_global_node_index" ref="00eb122a21ed5acd992dde2bb598259d" args="(size_t element_index, size_t node_index, size_t global_node_index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::set_global_node_index           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>element_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>node_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>global_node_index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the global node index of the node with index <em>node_index</em> on the element <em>element_index</em>. This index corresponds to the position of the node in the stiffness matrix and the force vector of the associated FE problem. 
<p>Referenced by <a class="el" href="fem_2utilities_8cxx-source.html#l00072">imaging::ellipse_grid()</a>, <a class="el" href="fem_2utilities_8cxx-source.html#l00162">imaging::triangulate_shape()</a>, and <a class="el" href="fem_2utilities_8cxx-source.html#l00023">imaging::uniform_grid()</a>.</p>

</div>
</div><p>
<a class="anchor" name="703df0fd19ba64f6cc50cce221463ee0"></a><!-- doxytag: member="imaging::Grid::set_boundary_element" ref="703df0fd19ba64f6cc50cce221463ee0" args="(size_t boundary_element_index, size_t parent_element_index, size_t parent_element_face)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::set_boundary_element           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>boundary_element_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>parent_element_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>parent_element_face</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the boundary element <em>boundary_element_index</em>. Note that the nodes on the boundary element are <em>not</em> automatically set to be boundary nodes; the user has to do this manually during grid construction. 
<p>References <a class="el" href="Grid_8hpp-source.html#l00223">imaging::Grid&lt; fem_types &gt;::element_transform()</a>, and <a class="el" href="Grid_8hpp-source.html#l00139">imaging::Grid&lt; fem_types &gt;::global_node_index()</a>.</p>

<p>Referenced by <a class="el" href="fem_2utilities_8cxx-source.html#l00072">imaging::ellipse_grid()</a>, <a class="el" href="fem_2utilities_8cxx-source.html#l00162">imaging::triangulate_shape()</a>, and <a class="el" href="fem_2utilities_8cxx-source.html#l00023">imaging::uniform_grid()</a>.</p>

</div>
</div><p>
<a class="anchor" name="de5ce3f534438b08369fc8cc34bef10f"></a><!-- doxytag: member="imaging::Grid::parent_element" ref="de5ce3f534438b08369fc8cc34bef10f" args="(size_t boundary_element_index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::parent_element           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>boundary_element_index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the index of the parent element of the boundary element <em>boundary_element_index</em>. 
<p>Referenced by <a class="el" href="Assembler_8hpp-source.html#l00072">imaging::Assembler::assemble()</a>, <a class="el" href="Assembler_8hpp-source.html#l00278">imaging::Assembler::assemble_force_vector()</a>, <a class="el" href="Assembler_8hpp-source.html#l00187">imaging::Assembler::assemble_stiffness_matrix()</a>, <a class="el" href="Grid_8hpp-source.html#l00308">imaging::Grid&lt; fem_types &gt;::interpolate_boundary_derivative()</a>, and <a class="el" href="Grid_8hpp-source.html#l00282">imaging::Grid&lt; fem_types &gt;::interpolate_boundary_value()</a>.</p>

</div>
</div><p>
<a class="anchor" name="5a8de87cdd9da39e0509bc9412ddaf6f"></a><!-- doxytag: member="imaging::Grid::parent_element_face" ref="5a8de87cdd9da39e0509bc9412ddaf6f" args="(size_t boundary_element_index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a> <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::parent_element_face           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>boundary_element_index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the index of the face of the parent element of the boundary element <em>boundary_element_index</em>. 
</div>
</div><p>
<a class="anchor" name="d7edf49be6e31971abed70f970e6292b"></a><!-- doxytag: member="imaging::Grid::is_boundary_node" ref="d7edf49be6e31971abed70f970e6292b" args="(size_t global_node_index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::is_boundary_node           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>global_node_index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the node <em>global_node_index</em> lies at the boundary of the grid. 
<p>Referenced by <a class="el" href="Grid_8hpp-source.html#l00177">imaging::Grid&lt; fem_types &gt;::is_boundary_node()</a>.</p>

</div>
</div><p>
<a class="anchor" name="88fcf85d1465b81ef33bee71205ce915"></a><!-- doxytag: member="imaging::Grid::is_boundary_node" ref="88fcf85d1465b81ef33bee71205ce915" args="(size_t element_index, size_t node_index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::is_boundary_node           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>element_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>node_index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the node <em>node_index</em> on the element <em>element_index</em> lies at the boundary of the grid. 
<p>References <a class="el" href="Grid_8hpp-source.html#l00139">imaging::Grid&lt; fem_types &gt;::global_node_index()</a>, and <a class="el" href="Grid_8hpp-source.html#l00171">imaging::Grid&lt; fem_types &gt;::is_boundary_node()</a>.</p>

</div>
</div><p>
<a class="anchor" name="9559cdc4969719992a7965a6189beb01"></a><!-- doxytag: member="imaging::Grid::boundary_normal" ref="9559cdc4969719992a7965a6189beb01" args="(size_t global_node_index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">vertex_t</a> <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::boundary_normal           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>global_node_index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the unit boundary normal of the node <em>global_node_index</em>. If the node happens not to be a boundary node an <a class="el" href="classimaging_1_1Exception.html" title="Generic exception with custom error message.">Exception</a> is thrown. 
<p>Referenced by <a class="el" href="Grid_8hpp-source.html#l00200">imaging::Grid&lt; fem_types &gt;::boundary_normal()</a>.</p>

</div>
</div><p>
<a class="anchor" name="65fcee35955b7e3fa29d7648d5698841"></a><!-- doxytag: member="imaging::Grid::boundary_normal" ref="65fcee35955b7e3fa29d7648d5698841" args="(size_t element_index, size_t node_index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">vertex_t</a> <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::boundary_normal           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>element_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>node_index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the unit boundary normal of the node <em>node_index</em> on the element <em>element_index</em>. If the node happens not to be a boundary node an <a class="el" href="classimaging_1_1Exception.html" title="Generic exception with custom error message.">Exception</a> is thrown. 
<p>References <a class="el" href="Grid_8hpp-source.html#l00183">imaging::Grid&lt; fem_types &gt;::boundary_normal()</a>, and <a class="el" href="Grid_8hpp-source.html#l00139">imaging::Grid&lt; fem_types &gt;::global_node_index()</a>.</p>

</div>
</div><p>
<a class="anchor" name="d0d54600dc8c664e1b09df0b68f4a205"></a><!-- doxytag: member="imaging::Grid::set_regular" ref="d0d54600dc8c664e1b09df0b68f4a205" args="(bool is_regular)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::set_regular           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_regular</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the grid is regular, i.e. the geometry of each of its elements is the identical modulo rigid transformation. Marking a grid as regular speeds up the assembly of the stiffness matrix and the force vector. Prominent examples of regular grids are pixel and voxel discretizations. 
</div>
</div><p>
<a class="anchor" name="2d84a94ce111449ac736ec49abf02b11"></a><!-- doxytag: member="imaging::Grid::is_regular" ref="2d84a94ce111449ac736ec49abf02b11" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::is_regular           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the grid is regular, i.e. the geometry of each of its elements is the identical modulo rigid transformation. Marking a grid as regular speeds up the assembly of the stiffness matrix and the force vector. Prominent examples of regular grids are pixel and voxel discretizations. 
<p>Referenced by <a class="el" href="Assembler_8hpp-source.html#l00072">imaging::Assembler::assemble()</a>, <a class="el" href="Assembler_8hpp-source.html#l00278">imaging::Assembler::assemble_force_vector()</a>, <a class="el" href="Assembler_8hpp-source.html#l00187">imaging::Assembler::assemble_stiffness_matrix()</a>, <a class="el" href="FeFunctionInterface_8hpp-source.html#l00181">imaging::average()</a>, <a class="el" href="FeFunctionInterface_8hpp-source.html#l00051">imaging::integrate()</a>, <a class="el" href="FeFunctionInterface_8hpp-source.html#l00095">imaging::maximum()</a>, and <a class="el" href="FeFunctionInterface_8hpp-source.html#l00137">imaging::minimum()</a>.</p>

</div>
</div><p>
<a class="anchor" name="8103c8b3047f28d7c4907d0b33a30db4"></a><!-- doxytag: member="imaging::Grid::set_dimensions" ref="8103c8b3047f28d7c4907d0b33a30db4" args="(size_t n_vertices, size_t n_elements, size_t n_boundary_elements, size_t n_nodes)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::set_dimensions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>n_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>n_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>n_boundary_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>n_nodes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the dimensions of the grid. The parameters refer to the <em>total</em> numbers of vertices, elements, boundary elements and nodes, respectively. Note that vertices or nodes which belong to more than one element are only counted once. 
<p>Referenced by <a class="el" href="fem_2utilities_8cxx-source.html#l00072">imaging::ellipse_grid()</a>, <a class="el" href="fem_2utilities_8cxx-source.html#l00162">imaging::triangulate_shape()</a>, and <a class="el" href="fem_2utilities_8cxx-source.html#l00023">imaging::uniform_grid()</a>.</p>

</div>
</div><p>
<a class="anchor" name="2649307cce81bde332c507d33deaa557"></a><!-- doxytag: member="imaging::Grid::element_transform" ref="2649307cce81bde332c507d33deaa557" args="(size_t element_index, transform_t &amp;transform) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::element_transform           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>element_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classimaging_1_1Grid.html#340246aba7d3d724f9e4f0cc07a72a41">transform_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>transform</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes the element transformation <em>transform</em> to the element <em>element_index</em>. 
<p>References <a class="el" href="Grid_8hpp-source.html#l00133">imaging::Grid&lt; fem_types &gt;::global_vertex_index()</a>, and <a class="el" href="Grid_8hpp-source.html#l00062">imaging::Grid&lt; fem_types &gt;::n_element_vertices</a>.</p>

<p>Referenced by <a class="el" href="Grid_8hpp-source.html#l00332">imaging::Grid&lt; fem_types &gt;::global_coordinates()</a>, and <a class="el" href="Grid_8hpp-source.html#l00145">imaging::Grid&lt; fem_types &gt;::set_boundary_element()</a>.</p>

</div>
</div><p>
<a class="anchor" name="27413c9e0eec188e35203506921f9078"></a><!-- doxytag: member="imaging::Grid::interpolate_value" ref="27413c9e0eec188e35203506921f9078" args="(size_t integrator_node, const ublas::vector&lt; float_t &gt; &amp;data, const FemKernel&lt; fem_types &gt; &amp;kernel, float_t &amp;value) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::interpolate_value           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>integrator_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ublas::vector&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; fem_types &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interpolates <em>data</em> in <em>integrator_node</em> on the current element of <em>kernel</em>. The result is written to <em>value</em>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>A vector of size <a class="el" href="classimaging_1_1Grid.html#db1f6524c9d947a9014f114ae1dc2a3e">n_nodes()</a>. Its values can be interpreted as the evaluation of a scalar function on the nodes of the grid. <a class="el" href="classimaging_1_1Grid.html#27413c9e0eec188e35203506921f9078">interpolate_value()</a> interpolates these values and evaluates the interpolation. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>kernel</em>&nbsp;</td><td>A <a class="el" href="classimaging_1_1FemKernel.html" title="Computes the values of the shape functions and the element transformation in the...">FemKernel</a> object. It must be initialized to a valid element of the grid. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="FemKernel_8hpp-source.html#l00121">imaging::FemKernel&lt; fem_types &gt;::current_element()</a>, <a class="el" href="Grid_8hpp-source.html#l00139">imaging::Grid&lt; fem_types &gt;::global_node_index()</a>, <a class="el" href="Grid_8hpp-source.html#l00065">imaging::Grid&lt; fem_types &gt;::n_element_nodes</a>, and <a class="el" href="FemKernel_8hpp-source.html#l00093">imaging::FemKernel&lt; fem_types &gt;::shape_value()</a>.</p>

</div>
</div><p>
<a class="anchor" name="7c1d3bcebbd329a809a10833aa585dea"></a><!-- doxytag: member="imaging::Grid::interpolate_value" ref="7c1d3bcebbd329a809a10833aa585dea" args="(size_t integrator_node, const ublas::vector&lt; float_t &gt; &amp;data, const FemKernel&lt; fem_types &gt; &amp;kernel, ublas::fixed_vector&lt; float_t, N &gt; &amp;value) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
<div class="memtemplate">
template&lt;size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::interpolate_value           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>integrator_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ublas::vector&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; fem_types &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">ublas::fixed_vector</a>&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>, N &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interpretes <em>data</em> as a vector of <em>N</em>-dimensional vectors and interpolates it in <em>integrator_node</em> on the current element of <em>kernel</em>. The result is written to <em>value</em>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>A vector of size (<em>N</em> * <a class="el" href="classimaging_1_1Grid.html#db1f6524c9d947a9014f114ae1dc2a3e">n_nodes()</a>). Its values can be interpreted as the evaluation of an <em>N</em>-dimensional function on the nodes of the grid. <a class="el" href="classimaging_1_1Grid.html#27413c9e0eec188e35203506921f9078">interpolate_value()</a> interpolates these values and evaluates the interpolation. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>kernel</em>&nbsp;</td><td>A <a class="el" href="classimaging_1_1FemKernel.html" title="Computes the values of the shape functions and the element transformation in the...">FemKernel</a> object. It must be initialized to a valid element of the grid. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="FemKernel_8hpp-source.html#l00121">imaging::FemKernel&lt; fem_types &gt;::current_element()</a>, <a class="el" href="Grid_8hpp-source.html#l00139">imaging::Grid&lt; fem_types &gt;::global_node_index()</a>, <a class="el" href="Grid_8hpp-source.html#l00065">imaging::Grid&lt; fem_types &gt;::n_element_nodes</a>, and <a class="el" href="FemKernel_8hpp-source.html#l00093">imaging::FemKernel&lt; fem_types &gt;::shape_value()</a>.</p>

</div>
</div><p>
<a class="anchor" name="97763c7c85baf8e239db7d589152f058"></a><!-- doxytag: member="imaging::Grid::interpolate_gradient" ref="97763c7c85baf8e239db7d589152f058" args="(size_t integrator_node, const ublas::vector&lt; float_t &gt; &amp;data, const FemKernel&lt; fem_types &gt; &amp;kernel, ublas::fixed_vector&lt; float_t, data_dimension &gt; &amp;gradient) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::interpolate_gradient           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>integrator_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ublas::vector&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; fem_types &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">ublas::fixed_vector</a>&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>, <a class="el" href="classimaging_1_1Grid.html#e4cd83c5d52896a4b27627575ecb9163">data_dimension</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gradient</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interpolates the gradient of <em>data</em> in <em>integrator_node</em> on the current element of <em>kernel</em>. The result is written to <em>value</em>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>A vector of size <a class="el" href="classimaging_1_1Grid.html#db1f6524c9d947a9014f114ae1dc2a3e">n_nodes()</a>. Its values can be interpreted as the evaluation of a scalar function on the nodes of the grid. <a class="el" href="classimaging_1_1Grid.html#27413c9e0eec188e35203506921f9078">interpolate_value()</a> interpolates these values and evaluates the gradient of the interpolation. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>kernel</em>&nbsp;</td><td>A <a class="el" href="classimaging_1_1FemKernel.html" title="Computes the values of the shape functions and the element transformation in the...">FemKernel</a> object. It must be initialized to a valid element of the grid. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="FemKernel_8hpp-source.html#l00121">imaging::FemKernel&lt; fem_types &gt;::current_element()</a>, <a class="el" href="Grid_8hpp-source.html#l00139">imaging::Grid&lt; fem_types &gt;::global_node_index()</a>, <a class="el" href="Grid_8hpp-source.html#l00065">imaging::Grid&lt; fem_types &gt;::n_element_nodes</a>, and <a class="el" href="FemKernel_8hpp-source.html#l00097">imaging::FemKernel&lt; fem_types &gt;::shape_gradient()</a>.</p>

</div>
</div><p>
<a class="anchor" name="1ef3411ee338c8700107155fabf1fc46"></a><!-- doxytag: member="imaging::Grid::interpolate_gradient" ref="1ef3411ee338c8700107155fabf1fc46" args="(size_t integrator_node, const ublas::vector&lt; float_t &gt; &amp;data, const FemKernel&lt; fem_types &gt; &amp;kernel, ublas::fixed_matrix&lt; float_t, data_dimension, N &gt; &amp;gradient) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
<div class="memtemplate">
template&lt;size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::interpolate_gradient           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>integrator_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ublas::vector&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; fem_types &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__matrix.html">ublas::fixed_matrix</a>&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>, <a class="el" href="classimaging_1_1Grid.html#e4cd83c5d52896a4b27627575ecb9163">data_dimension</a>, N &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gradient</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interpretes <em>data</em> as a vector of <em>N</em>-dimensional vectors and interpolates its gradient in <em>integrator_node</em> on the current element of <em>kernel</em>. The result is written to <em>value</em>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>A vector of size (<em>N</em> * <a class="el" href="classimaging_1_1Grid.html#db1f6524c9d947a9014f114ae1dc2a3e">n_nodes()</a>). Its values can be interpreted as the evaluation of an <em>N</em>-dimensional function on the nodes of the grid. <a class="el" href="classimaging_1_1Grid.html#27413c9e0eec188e35203506921f9078">interpolate_value()</a> interpolates these values and evaluates the gradient (a matrix) of the interpolation. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>kernel</em>&nbsp;</td><td>A <a class="el" href="classimaging_1_1FemKernel.html" title="Computes the values of the shape functions and the element transformation in the...">FemKernel</a> object. It must be initialized to a valid element of the grid. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="FemKernel_8hpp-source.html#l00121">imaging::FemKernel&lt; fem_types &gt;::current_element()</a>, <a class="el" href="Grid_8hpp-source.html#l00139">imaging::Grid&lt; fem_types &gt;::global_node_index()</a>, <a class="el" href="Grid_8hpp-source.html#l00065">imaging::Grid&lt; fem_types &gt;::n_element_nodes</a>, and <a class="el" href="FemKernel_8hpp-source.html#l00097">imaging::FemKernel&lt; fem_types &gt;::shape_gradient()</a>.</p>

</div>
</div><p>
<a class="anchor" name="33a73189dc4bb4f69211cdfdb247add3"></a><!-- doxytag: member="imaging::Grid::interpolate_boundary_value" ref="33a73189dc4bb4f69211cdfdb247add3" args="(size_t boundary_integrator_node, const ublas::mapped_vector&lt; float_t &gt; &amp;data, const FemKernel&lt; fem_types &gt; &amp;kernel, float_t &amp;value) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::interpolate_boundary_value           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>boundary_integrator_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ublas::mapped_vector&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; fem_types &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interpolates <em>data</em> in <em>boundary_integrator_node</em> on the current boundary element of <em>kernel</em>. The result is written to <em>value</em>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>A sparse vector of size <a class="el" href="classimaging_1_1Grid.html#db1f6524c9d947a9014f114ae1dc2a3e">n_nodes()</a>. It must contain values at positions which correspond to boundary nodes. Its values can be interpreted as the evaluation of a scalar function on the boundary nodes of the grid. <a class="el" href="classimaging_1_1Grid.html#27413c9e0eec188e35203506921f9078">interpolate_value()</a> interpolates these values and evaluates the interpolation. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>kernel</em>&nbsp;</td><td>A <a class="el" href="classimaging_1_1FemKernel.html" title="Computes the values of the shape functions and the element transformation in the...">FemKernel</a> object. It must be initialized to a valid boundary element of the grid. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="FemKernel_8hpp-source.html#l00124">imaging::FemKernel&lt; fem_types &gt;::current_boundary_element()</a>, <a class="el" href="Grid_8hpp-source.html#l00139">imaging::Grid&lt; fem_types &gt;::global_node_index()</a>, <a class="el" href="Grid_8hpp-source.html#l00065">imaging::Grid&lt; fem_types &gt;::n_element_nodes</a>, <a class="el" href="Grid_8hpp-source.html#l00165">imaging::Grid&lt; fem_types &gt;::parent_element()</a>, and <a class="el" href="FemKernel_8hpp-source.html#l00105">imaging::FemKernel&lt; fem_types &gt;::shape_boundary_value()</a>.</p>

</div>
</div><p>
<a class="anchor" name="7d0ad6eaa9bff5c8a9235b8467231cb4"></a><!-- doxytag: member="imaging::Grid::interpolate_boundary_value" ref="7d0ad6eaa9bff5c8a9235b8467231cb4" args="(size_t boundary_integrator_node, const ublas::mapped_vector&lt; float_t &gt; &amp;data, const FemKernel&lt; fem_types &gt; &amp;kernel, ublas::fixed_vector&lt; float_t, N &gt; &amp;value) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
<div class="memtemplate">
template&lt;size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::interpolate_boundary_value           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>boundary_integrator_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ublas::mapped_vector&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; fem_types &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">ublas::fixed_vector</a>&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>, N &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interpretes <em>data</em> as a vector of <em>N</em>-dimensional vectors and interpolates it in <em>boundary_integrator_node</em> on the current boundary element of <em>kernel</em>. The result is written to <em>value</em>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>A sparse vector of size (<em>N</em> * <a class="el" href="classimaging_1_1Grid.html#db1f6524c9d947a9014f114ae1dc2a3e">n_nodes()</a>). It must contain values at positions which correspond to boundary nodes. Its values can be interpreted as the evaluation of an <em>N</em>-dimensional function on the boundary nodes of the grid. <a class="el" href="classimaging_1_1Grid.html#27413c9e0eec188e35203506921f9078">interpolate_value()</a> interpolates these values and evaluates the interpolation. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>kernel</em>&nbsp;</td><td>A <a class="el" href="classimaging_1_1FemKernel.html" title="Computes the values of the shape functions and the element transformation in the...">FemKernel</a> object. It must be initialized to a valid boundary element of the grid. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="FemKernel_8hpp-source.html#l00124">imaging::FemKernel&lt; fem_types &gt;::current_boundary_element()</a>, <a class="el" href="Grid_8hpp-source.html#l00139">imaging::Grid&lt; fem_types &gt;::global_node_index()</a>, <a class="el" href="Grid_8hpp-source.html#l00065">imaging::Grid&lt; fem_types &gt;::n_element_nodes</a>, <a class="el" href="Grid_8hpp-source.html#l00165">imaging::Grid&lt; fem_types &gt;::parent_element()</a>, and <a class="el" href="FemKernel_8hpp-source.html#l00105">imaging::FemKernel&lt; fem_types &gt;::shape_boundary_value()</a>.</p>

</div>
</div><p>
<a class="anchor" name="639d16fceee54638ef934d420a38d2d6"></a><!-- doxytag: member="imaging::Grid::interpolate_boundary_derivative" ref="639d16fceee54638ef934d420a38d2d6" args="(size_t boundary_integrator_node, const ublas::mapped_vector&lt; float_t &gt; &amp;data, const FemKernel&lt; fem_types &gt; &amp;kernel, float_t &amp;value) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::interpolate_boundary_derivative           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>boundary_integrator_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ublas::mapped_vector&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; fem_types &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interpolates <em>the</em> tangential derivative of data in <em>boundary_integrator_node</em> on the current boundary element of <em>kernel</em>. The result is written to <em>value</em>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>A sparse vector of size <a class="el" href="classimaging_1_1Grid.html#db1f6524c9d947a9014f114ae1dc2a3e">n_nodes()</a>. It must contain values at positions which correspond to boundary nodes. Its values can be interpreted as the evaluation of a scalar function on the boundary nodes of the grid. <a class="el" href="classimaging_1_1Grid.html#27413c9e0eec188e35203506921f9078">interpolate_value()</a> interpolates these values and evaluates the tangential derivative of the interpolation. Note that it is not possible to compute the normal derivate if <em>data</em> is known only on the boundary. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>kernel</em>&nbsp;</td><td>A <a class="el" href="classimaging_1_1FemKernel.html" title="Computes the values of the shape functions and the element transformation in the...">FemKernel</a> object. It must be initialized to a valid boundary element of the grid. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="FemKernel_8hpp-source.html#l00124">imaging::FemKernel&lt; fem_types &gt;::current_boundary_element()</a>, <a class="el" href="Grid_8hpp-source.html#l00139">imaging::Grid&lt; fem_types &gt;::global_node_index()</a>, <a class="el" href="Grid_8hpp-source.html#l00065">imaging::Grid&lt; fem_types &gt;::n_element_nodes</a>, <a class="el" href="Grid_8hpp-source.html#l00165">imaging::Grid&lt; fem_types &gt;::parent_element()</a>, and <a class="el" href="FemKernel_8hpp-source.html#l00109">imaging::FemKernel&lt; fem_types &gt;::shape_boundary_derivative()</a>.</p>

</div>
</div><p>
<a class="anchor" name="447628fa4232daa9e7c137ef2813b1cb"></a><!-- doxytag: member="imaging::Grid::interpolate_boundary_derivative" ref="447628fa4232daa9e7c137ef2813b1cb" args="(size_t boundary_integrator_node, const ublas::mapped_vector&lt; float_t &gt; &amp;data, const FemKernel&lt; fem_types &gt; &amp;kernel, ublas::fixed_vector&lt; float_t, N &gt; &amp;value) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
<div class="memtemplate">
template&lt;size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::interpolate_boundary_derivative           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>boundary_integrator_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ublas::mapped_vector&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; fem_types &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">ublas::fixed_vector</a>&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>, N &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interpretes <em>data</em> as a vector of <em>N</em>-dimensional vectors and interpolates it in <em>boundary_integrator_node</em> on the current boundary element of <em>kernel</em>. The result is written to <em>value</em>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>A sparse vector of size (<em>N</em> * <a class="el" href="classimaging_1_1Grid.html#db1f6524c9d947a9014f114ae1dc2a3e">n_nodes()</a>). It must contain values at positions which correspond to boundary nodes. Its values can be interpreted as the evaluation of a <em>N</em>-dimensional function on the boundary nodes of the grid. <a class="el" href="classimaging_1_1Grid.html#27413c9e0eec188e35203506921f9078">interpolate_value()</a> interpolates these values and evaluates the tangential derivative of the interpolation. Note that it is not possible to compute the normal derivate if <em>data</em> is known only on the boundary. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>kernel</em>&nbsp;</td><td>A <a class="el" href="classimaging_1_1FemKernel.html" title="Computes the values of the shape functions and the element transformation in the...">FemKernel</a> object. It must be initialized to a valid boundary element of the grid. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="FemKernel_8hpp-source.html#l00124">imaging::FemKernel&lt; fem_types &gt;::current_boundary_element()</a>, <a class="el" href="Grid_8hpp-source.html#l00139">imaging::Grid&lt; fem_types &gt;::global_node_index()</a>, <a class="el" href="Grid_8hpp-source.html#l00065">imaging::Grid&lt; fem_types &gt;::n_element_nodes</a>, <a class="el" href="Grid_8hpp-source.html#l00165">imaging::Grid&lt; fem_types &gt;::parent_element()</a>, and <a class="el" href="FemKernel_8hpp-source.html#l00109">imaging::FemKernel&lt; fem_types &gt;::shape_boundary_derivative()</a>.</p>

</div>
</div><p>
<a class="anchor" name="40b55488ea9b6b8aab64dce21e383d22"></a><!-- doxytag: member="imaging::Grid::global_coordinates" ref="40b55488ea9b6b8aab64dce21e383d22" args="(size_t integrator_node, const FemKernel&lt; fem_types &gt; &amp;kernel, ublas::fixed_vector&lt; float_t, data_dimension &gt; &amp;coordinates) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class fem_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classimaging_1_1Grid.html">imaging::Grid</a>&lt; fem_types &gt;::global_coordinates           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#g9a15696a1ae77dcbdb1f0de8b115c2e6">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>integrator_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classimaging_1_1FemKernel.html">FemKernel</a>&lt; fem_types &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">ublas::fixed_vector</a>&lt; <a class="el" href="group__core.html#gf2c95632db94ddc193b32e57a1e8e2d9">float_t</a>, <a class="el" href="classimaging_1_1Grid.html#e4cd83c5d52896a4b27627575ecb9163">data_dimension</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>coordinates</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the global coordinates of the <em>integrator_node</em> on the current element of <em>kernel</em>. The result is written to <em>coordinates</em>. 
<p>References <a class="el" href="FemKernel_8hpp-source.html#l00121">imaging::FemKernel&lt; fem_types &gt;::current_element()</a>, and <a class="el" href="Grid_8hpp-source.html#l00223">imaging::Grid&lt; fem_types &gt;::element_transform()</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>imaging2/fem/<a class="el" href="Grid_8hpp-source.html">Grid.hpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Feb 10 10:01:31 2009 for imaging2 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
