<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>imaging2: Image Module</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Image Module</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1CastAccessor.html">imaging::CastAccessor&lt; image_t, DATA_t &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides casted pixel data type access to images.  <a href="classimaging_1_1CastAccessor.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Color.html">imaging::Color</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for 24-bit color values.  <a href="classimaging_1_1Color.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1GrayValue.html">imaging::GrayValue</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for 8-bit grayscale values.  <a href="classimaging_1_1GrayValue.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1Image.html">imaging::Image&lt; N, DATA_t &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stores image data of arbitrary dimension and pixel type.  <a href="classimaging_1_1Image.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1ImageAccessorInterface.html">imaging::ImageAccessorInterface&lt; image_t, DATA_t &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract base class of all image accessor classes.  <a href="classimaging_1_1ImageAccessorInterface.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1ImageInterface.html">imaging::ImageInterface&lt; N, DATA_t &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract base class of all classes modelling image data.  <a href="classimaging_1_1ImageInterface.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1InterpolationAdaptorInterface.html">imaging::InterpolationAdaptorInterface&lt; image_t &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract base class of image interpolation function which provide pixel values in floating point coordinates.  <a href="classimaging_1_1InterpolationAdaptorInterface.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1PolynomialInterpolationAdaptor.html">imaging::PolynomialInterpolationAdaptor&lt; image_t &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Polynomial interpolation of image values at floating point coordinates.  <a href="classimaging_1_1PolynomialInterpolationAdaptor.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1ScalarImage.html">imaging::ScalarImage&lt; N, DATA_t &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Image with constant pixel values.  <a href="classimaging_1_1ScalarImage.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1ScalingAccessor.html">imaging::ScalingAccessor&lt; float_accessor_t &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides access to rescaled floating point images.  <a href="classimaging_1_1ScalingAccessor.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classimaging_1_1VectorComponentAccessor.html">imaging::VectorComponentAccessor&lt; vector_image_t &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides access to different channels of vector valued image data.  <a href="classimaging_1_1VectorComponentAccessor.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef Image&lt; 2, Color &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image.html#ga4b848bedfd05236c420dd424c01bedb">imaging::ColorImage2d</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">2-dimensional color image.  <a href="#ga4b848bedfd05236c420dd424c01bedb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef Image&lt; 2, GrayValue &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image.html#g61a7739979e33166f77f0d99c12d6c60">imaging::GrayImage2d</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">2-dimensional grayscale image.  <a href="#g61a7739979e33166f77f0d99c12d6c60"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef Image&lt; 3, GrayValue &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image.html#gf0dda3a6313c09c7a0ae11335eb0342b">imaging::GrayImage3d</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">3-dimensional grayscale image.  <a href="#gf0dda3a6313c09c7a0ae11335eb0342b"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;size_t N, class DATA_t&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image.html#g67cd7a98c4e38d539fb0c6e2247cbb89">imaging::operator&lt;&lt;</a> (std::ostream &amp;out, const ImageInterface&lt; N, DATA_t &gt; &amp;image)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image.html#g815717382d4d68a343ef3b8be51f9bb4">imaging::operator&lt;&lt;</a> (std::ostream &amp;out, const GrayValue value)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image.html#g4d4445993f7ff4d20829e5867718f91a">imaging::operator&lt;&lt;</a> (std::ostream &amp;out, const Color &amp;value)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::istream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image.html#g44cd463dc1a4b77d7e2be3725598f8c5">imaging::operator&gt;&gt;</a> (std::istream &amp;in, GrayValue &amp;value)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::istream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image.html#g63352f856470cdb0cd64083c443f2a3d">imaging::operator&gt;&gt;</a> (std::istream &amp;in, Color &amp;value)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">GraphicsInterface &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image.html#gd3637baf0a08d135bebca13402134e95">imaging::operator&lt;&lt;</a> (GraphicsInterface &amp;out, const ColorImage2d &amp;image)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class float_accessor_t, class vector_accessor_t&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image.html#g242d32218642f8b7fd693e3b326e8c4a">imaging::compute_divergence_field</a> (const float_accessor_t &amp;image, vector_accessor_t &amp;out)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class image_t&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image.html#gd1f8b19cf820f8d979127ec0cd2c5b8f">imaging::blur</a> (image_t &amp;image, float_t width, float_t sigma)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class image_t&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image.html#g9984561628be8d7e256f6608b019ed19">imaging::edge</a> (image_t &amp;image, float_t radius)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class image_t&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image.html#g85dfbc0fc06d5f26071d9b9a4fa178fa">imaging::absolute_gradient</a> (image_t &amp;image)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class image_t&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">image_t::data_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image.html#g591231f64db4bd72fd6e8e585b6ceff3">imaging::max</a> (const image_t &amp;image)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class image_t&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">image_t::data_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image.html#gcfe4f306c25e81589be8d5d0d9a7dfd9">imaging::min</a> (const image_t &amp;image)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class image_t&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image.html#g9dcd3fb5b2fdd378db31902de5701165">imaging::is_pixel</a> (const image_t &amp;image, const <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">ublas::fixed_vector</a>&lt; size_t, image_t::dimension &gt; &amp;index)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image.html#g20b421f5a7d5bbb456e4593c883baa30">imaging::draw_level_set</a> (const Image&lt; 2, float_t &gt; &amp;level_set_function, const float_t &amp;level, const Color &amp;color, ColorImage2d &amp;image)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image.html#gf68f992f1198b579c9eb98a3caebcb07">imaging::image2matrix</a> (const Image&lt; 2, float_t &gt; &amp;image, ublas::matrix&lt; float_t &gt; &amp;matrix)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The image module provides a template class for <em>n</em>-dimensional image data and specialized members to read and write 2-dimensional image data. Furthermore, the concept of <em>accessor</em> classes allows to apply simple transformations to images on the fly or efficiently access channels of vector valued image data. For 2D image data, several functions of the <a href="http://www.imagemagick.org">ImageMagick</a> library are interfaced. <hr><h2>Typedef Documentation</h2>
<a class="anchor" name="ga4b848bedfd05236c420dd424c01bedb"></a><!-- doxytag: member="imaging::ColorImage2d" ref="ga4b848bedfd05236c420dd424c01bedb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Image&lt;2, Color&gt; <a class="el" href="classimaging_1_1Image.html">imaging::ColorImage2d</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
2-dimensional color image. 
<p>
<code>#include &lt;<a class="el" href="Color_8hpp-source.html">image/Color.hpp</a>&gt;</code><p>
Abbreviated notation for 2-dimensional color images. The colors values are stored with 24 bit precision. i.e. each pixel is represented by 3 (red, green, blue) integer values 0-255.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classimaging_1_1Color.html" title="Class for 24-bit color values.">Color</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g61a7739979e33166f77f0d99c12d6c60"></a><!-- doxytag: member="imaging::GrayImage2d" ref="g61a7739979e33166f77f0d99c12d6c60" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Image&lt;2, GrayValue&gt; <a class="el" href="classimaging_1_1Image.html">imaging::GrayImage2d</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
2-dimensional grayscale image. 
<p>
<code>#include &lt;<a class="el" href="GrayValue_8hpp-source.html">image/GrayValue.hpp</a>&gt;</code><p>
Abbreviated notation for 2-dimensional grayscale images. The gray values are stored with 8 bit precision. i.e. each pixel is represented by an integer value 0-255.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classimaging_1_1GrayValue.html" title="Class for 8-bit grayscale values.">GrayValue</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf0dda3a6313c09c7a0ae11335eb0342b"></a><!-- doxytag: member="imaging::GrayImage3d" ref="gf0dda3a6313c09c7a0ae11335eb0342b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Image&lt;3, GrayValue&gt; <a class="el" href="classimaging_1_1Image.html">imaging::GrayImage3d</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
3-dimensional grayscale image. 
<p>
<code>#include &lt;<a class="el" href="GrayValue_8hpp-source.html">image/GrayValue.hpp</a>&gt;</code><p>
Abbreviated notation for 3-dimensional grayscale images. The gray values are stored with 8 bit precision. i.e. each pixel is represented by an integer value 0-255.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classimaging_1_1GrayValue.html" title="Class for 8-bit grayscale values.">GrayValue</a> </dd></dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g85dfbc0fc06d5f26071d9b9a4fa178fa"></a><!-- doxytag: member="imaging::absolute_gradient" ref="g85dfbc0fc06d5f26071d9b9a4fa178fa" args="(image_t &amp;image)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class image_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void imaging::absolute_gradient           </td>
          <td>(</td>
          <td class="paramtype">image_t &amp;&nbsp;</td>
          <td class="paramname"> <em>image</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>#include &lt;image/utilities.hpp&gt;</code><p>
Computes the absolute value of the gradient of <em>image</em> in the following way:<ul>
<li>the gradient of the inner pixels of <em>image</em> is computed using symmetric finite differences,</li><li>the inner pixels of <em>image</em> are set to the absolute value of the gradients computed in the previous step,</li><li>the values of the boundary pixels (excluding the pixels in the corners) <em>image</em> are set to the values of the neighboring inner pixels,</li><li>the values of the boundary pixels are set to the mean of the values in the neighboring pixels. This is implemented for 2-dimensional images only, but the above procedure generalizes to higher dimensions (somebody must implement it, though). </li></ul>

</div>
</div><p>
<a class="anchor" name="gd1f8b19cf820f8d979127ec0cd2c5b8f"></a><!-- doxytag: member="imaging::blur" ref="gd1f8b19cf820f8d979127ec0cd2c5b8f" args="(image_t &amp;image, float_t width, float_t sigma)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class image_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void imaging::blur           </td>
          <td>(</td>
          <td class="paramtype">image_t &amp;&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_t&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_t&nbsp;</td>
          <td class="paramname"> <em>sigma</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>#include &lt;image/utilities.hpp&gt;</code><p>
Blurs <em>image</em> by convoluting it with a Gaussian kernel with standard deviation <em>sigma</em> (in pixels). The parameter <em>width</em> determines the radius of the kernel in pixels. This function is currently implemented for 2-dimensional images only (using ImageMagick). 
</div>
</div><p>
<a class="anchor" name="g242d32218642f8b7fd693e3b326e8c4a"></a><!-- doxytag: member="imaging::compute_divergence_field" ref="g242d32218642f8b7fd693e3b326e8c4a" args="(const float_accessor_t &amp;image, vector_accessor_t &amp;out)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class float_accessor_t, class vector_accessor_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void imaging::compute_divergence_field           </td>
          <td>(</td>
          <td class="paramtype">const float_accessor_t &amp;&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_accessor_t &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>#include &lt;image/utilities.hpp&gt;</code><p>
Computes a vector field <em>out</em> such that the divergence of <em>out</em> equals the scalar input <em>image</em>. If we denote <img class="formulaInl" alt="$f$" src="form_22.png"> and <em>out</em> as <img class="formulaInl" alt="$\vec F$" src="form_9.png"> then this means that <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \nabla \cdot \vec F = f\,. \]" src="form_65.png">
<p>
 This is done by setting <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \vec F_n(x_1, \ldots, x_n, \ldots, x_N) = \frac1N \int_0^{x_n}f(x_1, \ldots, \xi, \ldots, x_N) d\xi\,, \]" src="form_66.png">
<p>
 where <img class="formulaInl" alt="$N$" src="form_67.png"> denotes the dimension of <em>image</em>.<p>
The dimension of <em>image</em> must equal the number of components of each pixel in <em>out</em>. 
<p>References <a class="el" href="Image_8hpp-source.html#l00048">imaging::increment_index()</a>.</p>

<p>Referenced by <a class="el" href="MumfordShahEnergy_8hpp-source.html#l00095">imaging::MumfordShahEnergy&lt; shape_t &gt;::MumfordShahEnergy()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g20b421f5a7d5bbb456e4593c883baa30"></a><!-- doxytag: member="imaging::draw_level_set" ref="g20b421f5a7d5bbb456e4593c883baa30" args="(const Image&lt; 2, float_t &gt; &amp;level_set_function, const float_t &amp;level, const Color &amp;color, ColorImage2d &amp;image)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imaging::draw_level_set           </td>
          <td>(</td>
          <td class="paramtype">const Image&lt; 2, float_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>level_set_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float_t &amp;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Color &amp;&nbsp;</td>
          <td class="paramname"> <em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ColorImage2d &amp;&nbsp;</td>
          <td class="paramname"> <em>image</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>#include &lt;image/utilities.hpp&gt;</code><p>
Draws the level line of <em>level_set_function</em> defined by <em>level</em> onto <em>image</em> using <em>color</em>. Implemented for 2-dimensional images only. 
<p>References <a class="el" href="Image_8hpp-source.html#l00149">imaging::Image&lt; N, DATA_t &gt;::size()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g9984561628be8d7e256f6608b019ed19"></a><!-- doxytag: member="imaging::edge" ref="g9984561628be8d7e256f6608b019ed19" args="(image_t &amp;image, float_t radius)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class image_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void imaging::edge           </td>
          <td>(</td>
          <td class="paramtype">image_t &amp;&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_t&nbsp;</td>
          <td class="paramname"> <em>radius</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>#include &lt;image/utilities.hpp&gt;</code><p>
Calls the <em>edge</em> function of ImageMagick. No idea what it does. Implemented for 2-dimensional images only. 
</div>
</div><p>
<a class="anchor" name="gf68f992f1198b579c9eb98a3caebcb07"></a><!-- doxytag: member="imaging::image2matrix" ref="gf68f992f1198b579c9eb98a3caebcb07" args="(const Image&lt; 2, float_t &gt; &amp;image, ublas::matrix&lt; float_t &gt; &amp;matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imaging::image2matrix           </td>
          <td>(</td>
          <td class="paramtype">const Image&lt; 2, float_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ublas::matrix&lt; float_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>#include &lt;image/utilities.hpp&gt;</code><p>
Converts the 2-dimensional <em>image</em> to <em>matrix</em>. 
<p>References <a class="el" href="Image_8hpp-source.html#l00149">imaging::Image&lt; N, DATA_t &gt;::size()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g9dcd3fb5b2fdd378db31902de5701165"></a><!-- doxytag: member="imaging::is_pixel" ref="g9dcd3fb5b2fdd378db31902de5701165" args="(const image_t &amp;image, const ublas::fixed_vector&lt; size_t, image_t::dimension &gt; &amp;index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class image_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool imaging::is_pixel           </td>
          <td>(</td>
          <td class="paramtype">const image_t &amp;&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1numeric_1_1ublas_1_1fixed__vector.html">ublas::fixed_vector</a>&lt; size_t, image_t::dimension &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>#include &lt;image/utilities.hpp&gt;</code><p>
Returns true if the pixel defined by <em>index</em> is within the bounds of <em>image</em> and false otherwise. 
</div>
</div><p>
<a class="anchor" name="g591231f64db4bd72fd6e8e585b6ceff3"></a><!-- doxytag: member="imaging::max" ref="g591231f64db4bd72fd6e8e585b6ceff3" args="(const image_t &amp;image)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class image_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">image_t::data_t imaging::max           </td>
          <td>(</td>
          <td class="paramtype">const image_t &amp;&nbsp;</td>
          <td class="paramname"> <em>image</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>#include &lt;image/utilities.hpp&gt;</code><p>
Computes the maximal pixel value of <em>image</em>. The class <em>image_t</em> must implement <a class="el" href="classimaging_1_1ImageInterface.html" title="Abstract base class of all classes modelling image data.">ImageInterface</a> and <em>image_t::data_t</em> must be comparable. 
<p>References <a class="el" href="Image_8hpp-source.html#l00048">imaging::increment_index()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gcfe4f306c25e81589be8d5d0d9a7dfd9"></a><!-- doxytag: member="imaging::min" ref="gcfe4f306c25e81589be8d5d0d9a7dfd9" args="(const image_t &amp;image)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class image_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">image_t::data_t imaging::min           </td>
          <td>(</td>
          <td class="paramtype">const image_t &amp;&nbsp;</td>
          <td class="paramname"> <em>image</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>#include &lt;image/utilities.hpp&gt;</code><p>
Computes the minimal pixel value of <em>image</em>. The class <em>image_t</em> must implement <a class="el" href="classimaging_1_1ImageInterface.html" title="Abstract base class of all classes modelling image data.">ImageInterface</a> and <em>image_t::data_t</em> must be comparable. 
<p>References <a class="el" href="Image_8hpp-source.html#l00048">imaging::increment_index()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gd3637baf0a08d135bebca13402134e95"></a><!-- doxytag: member="imaging::operator&lt;&lt;" ref="gd3637baf0a08d135bebca13402134e95" args="(GraphicsInterface &amp;out, const ColorImage2d &amp;image)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GraphicsInterface &amp; imaging::operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">GraphicsInterface &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ColorImage2d &amp;&nbsp;</td>
          <td class="paramname"> <em>image</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>#include &lt;image/gio.hpp&gt;</code><p>
Draws <em>image</em> in the graphics output. The lower left corner of the image will be located at the origin (0, 0) and the upper right corner at (image.size()(0), image.size()(1)). In other words, this functions assumes the axes system of the graphics output to be scaled to pixel size. 
<p>References <a class="el" href="classimaging_1_1GraphicsInterface.html#a1e9e882a8e86a6dfe0f1da3fd108714">imaging::GraphicsInterface::image()</a>, and <a class="el" href="Image_8hpp-source.html#l00149">imaging::Image&lt; N, DATA_t &gt;::size()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g4d4445993f7ff4d20829e5867718f91a"></a><!-- doxytag: member="imaging::operator&lt;&lt;" ref="g4d4445993f7ff4d20829e5867718f91a" args="(std::ostream &amp;out, const Color &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; imaging::operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Color &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>#include &lt;image/cio.hpp&gt;</code> 
</div>
</div><p>
<a class="anchor" name="g815717382d4d68a343ef3b8be51f9bb4"></a><!-- doxytag: member="imaging::operator&lt;&lt;" ref="g815717382d4d68a343ef3b8be51f9bb4" args="(std::ostream &amp;out, const GrayValue value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; imaging::operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GrayValue&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>#include &lt;image/cio.hpp&gt;</code> 
</div>
</div><p>
<a class="anchor" name="g67cd7a98c4e38d539fb0c6e2247cbb89"></a><!-- doxytag: member="imaging::operator&lt;&lt;" ref="g67cd7a98c4e38d539fb0c6e2247cbb89" args="(std::ostream &amp;out, const ImageInterface&lt; N, DATA_t &gt; &amp;image)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, class DATA_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; imaging::operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ImageInterface&lt; N, DATA_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>image</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>#include &lt;image/cio.hpp&gt;</code> 
</div>
</div><p>
<a class="anchor" name="g63352f856470cdb0cd64083c443f2a3d"></a><!-- doxytag: member="imaging::operator&gt;&gt;" ref="g63352f856470cdb0cd64083c443f2a3d" args="(std::istream &amp;in, Color &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; imaging::operator&gt;&gt;           </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>#include &lt;image/cio.hpp&gt;</code> 
</div>
</div><p>
<a class="anchor" name="g44cd463dc1a4b77d7e2be3725598f8c5"></a><!-- doxytag: member="imaging::operator&gt;&gt;" ref="g44cd463dc1a4b77d7e2be3725598f8c5" args="(std::istream &amp;in, GrayValue &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; imaging::operator&gt;&gt;           </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrayValue &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>#include &lt;image/cio.hpp&gt;</code> 
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Feb 10 10:01:31 2009 for imaging2 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
